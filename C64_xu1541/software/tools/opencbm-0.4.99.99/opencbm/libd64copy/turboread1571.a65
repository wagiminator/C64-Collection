; Copyright (C) 1994-2004 Joe Forster/STA <sta(at)c64(dot)org>
; All rights reserved.
;
; This file is part of OpenCBM
;
; Redistribution and use in source and binary forms, with or without
; modification, are permitted provided that the following conditions are met:
;
;     * Redistributions of source code must retain the above copyright
;       notice, this list of conditions and the following disclaimer.
;     * Redistributions in binary form must reproduce the above copyright
;       notice, this list of conditions and the following disclaimer in
;       the documentation and/or other materials provided with the
;       distribution.
;     * Neither the name of the OpenCBM team nor the names of its
;       contributors may be used to endorse or promote products derived
;       from this software without specific prior written permission.
;
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
; IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
; TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
; PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
; OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
; EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
; PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
; PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
; LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
; NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;

	* = $0500

	tr = $0a
	se = tr+1

	buf = $f9
	drv = $7f

	dbufptr    = $31
	n_sectors  = $43
	retry_mode = $6a
	bump_cnt   = $8d

	get_ts     = $0700
	send_byte  = $0709
	send_block = $070c
	init       = $070f

	do_read    = $0400

	jmp main

	lda $180f
	pha
	ora #$20
	sta $180f
	jsr init
	ldy #$ff	; copy read
i0	lda $960f,y	; routine from rom
	sta do_read-1,y	; to $0400
	dey
	bne i0
	ldy #$36	; retry routine
i1:	lda $d5f8,y
	sta do_retry,y
	dey
	bpl i1
	lda #$60	; patch (rts)
	sta do_read+$fa	; read routine
	sta do_retry+$37; retry routine
	lda #$57
	sta do_read+$29
	lda #$2b
	sta do_read+$c5
	lda #>do_read
	sta do_read+$2a
	sta do_read+$c6
	ldx drv		; drive number
	lda $feca,x	; led
	sta $026d	; mask
	lda #$01	; "init disk"
	sta $1c,x	; flag
start	lda #$02	; buffer ($0500)
	sta buf		; number
	sta bump_cnt
	sei
	jsr get_ts	; get track/sector
	stx tr
	sty se
	cli
exec	lda tr
	beq done
	ldx buf		; buffer
	lda #$e0	; execute buffer
	jsr $d57d	; set job parameters
wait	lda $00,x	; wait until
	bmi wait	; job has finished
check	beq exec
	jsr $d6a6	; execute job w/ retry
	bcc check	; no error
	bit retry_mode	; try halftracks?
	bvs noht	; no -> skip
	jsr do_retry
	bcc check
noht	bit retry_mode	; bump head?
	bmi nobump	; no -> skip
	dec bump_cnt
	beq nobump
	lda #$c0	; bump it!
	jsr $d57d
	jsr $d599
	bne exec
nobump	sei
	jsr send_byte
	ldy #$00
	jsr send_block
	cli
	jmp start
done	sta $1800	; A == 0
	pla
	sta $180f
	jmp $c194

main	lda tr		; current track
	cmp $02ac	; > max. nr of tracks?
	bcc legal
	lda $1c00	; yes, set
	and #$9f	; bitrate
	sta $1c00
	lda #$11	; nr of sectors (17)
	sta n_sectors	; for tracks > 35
legal	lda #$03	; buffer address
	sta dbufptr	; (hi)
	jsr $9600
	jsr do_read	; read sector
	lda #$00
	jsr send_byte
	lda $026d	; flash
	eor $1c00	; led
	sta $1c00
	ldy #$00
	jsr send_block	; transfer sector
	lda #$02
	sta bump_cnt
	jsr get_ts
	cpx tr		; same track?
	stx tr		; store track
	sty se		; store sector
	beq main	; yes, same track
	lda #$00	; no error
	jmp $99b5	; terminate job

do_retry = *
