<!doctype linuxdoc system>

<article>
<title>opencbm 0.4.99.99 Users Guide
<author>Michael Klein, <htmlurl url="mailto:nip@c64.org" name="nip@c64.org">,
Spiro Trikaliotis, <htmlurl url="mailto:cbm4win@trikaliotis.net"
name="cbm4win@trikaliotis.net">, Wolfgang Moser <htmlurl url="http://d81.de/" name="d81.de">,
Arnd Menge <htmlurl url="mailto:arnd(at)jonnz(dot)de" name="arnd(at)jonnz(dot)de">,
<date>2016-01-13

<abstract>
This document describes the opencbm package, which can be used to control and
use serial devices as userd by most Commodore (CBM) 8-bit machines.

The latest version of the document can be found online at <htmlurl
url="http://opencbm.trikaliotis.net/" name="http://opencbm,trikaliotis.net/">.

OpenCBM consists of a kernel module ("driver") for Linux and Windows for cables
connected via the parallel port, which is almost obsolete on modern PC
hardware. Additionally, it has support software and tools to access these old
parallel port based cables as well as more modern USB replacements.

On top of that, a few user space support programs to control and use serial
devices as used by most Commodore (CBM) 8-bit machines are included.

The document also contains descriptions for the corresponding cables, namely,
the XU1541 adapter, the XUM1541 adapter (a.k.a. "ZoomFloppy"), and the
XA1541/XM1541 adapter.
</abstract>

<!-- Table of contents -->
<toc>

<!-- List of figures -->

<lof>

<!-- Begin the document -->

<sect>Overview<label id="overview">

<p>
<em/Please read the section <ref id="WARNINGS" name="WARNINGS"> at the end of
this document before proceeding. Improper use of the cable adapters (XA1541,
XU1541, XUM1541) may damage your drives or the cables themselves./

<p>
The popular Commodore 8-bit home-computers like the C-64 and the VIC-20 are
using a custom serial bus to talk to attached devices (disk drive, printer).
This proprietary serial bus protocol is not natively supported by modern hard-
or software.

opencbm provides an interface to this so-called IEC bus at the level of simple
TALK and LISTEN commands, similar to the one provided by the Commodore kernel
routines. Additionally, some higher and lower level bus control is available as
well, allowing for full control of the bus.

The CBM serial devices are connected to the PC either to the parallel port via
an XM1541 or XA1541 cable and, optionally, an XP1541 or XP1571 add-on cable.
Alternatively, more modern USB cable solutions like XU1541 or XUM1541 (a.k.a.
ZoomFloppy) are supported. For cables, cf. <ref
id="cable" name="cable">.

opencbm has a plugin concept which allows to additionally add custom build
cables.

opencbm can be used on PCs on Linux and Windows (all cables). Additioanlly, USB
based cables are supported on FreeBSD and on Mac OS X.

<sect1>Introduction to opencbm<label id="introduction">

<p>
This is version 0.4.99.99 of opencbm, a support package for retro devices that
communicate with the serial CBM bus protocol, known from the C64, VIC-20, etc.
Opencbm runs on Linux, Windows, FreeBSD and Mac OS X.  opencbm 0.4.0 was a
re-join of the two projects cbm4linux (latest standalone version: 0.3.2) and
cbm4win (latest standalone version: 0.1.0a). It should be noted that both
projects were highly related from the beginning, as cbm4win 0.1.0 was based on
cbm4linux 0.3.2.

Opencbm should work with any devices that understand the "normal" talk and
listen commands of the CBM IEC bus. It has been tested with several 1541,
1541-II, 1570, 1571 and 1581 drives, and a MPS-1200 printer. 1541 clones like
the Oceanic OC-118 have also been reported to work.

The following cable types are supported: 

<p>
<itemize>
<item>XUM1541            (opencbm version >= 0.4.99.x)
<item>XU1541             (opencbm version >= 0.4.99.x)
<item>XM1541 and XA1541  (cbm4linux version >= 0.2.1, cbm4win version >= 0.1.0)
<item>XP1541             (cbm4linux version >= 0.2.0, cbm4win version >= 0.1.0)
<item>XP1571             (cbm4linux version >= 0.2.4, cbm4win version >= 0.1.0)
<item>Modified XE1541    (only on Linux, obsoleted by the XM1541, see
`opencbm/LINUX/config.make')
</itemize>

More information on the different cable types can be found in <ref id="cable"
name="cable">.

This package is provided `as is', no warranty of any kind will be taken for any
damage or data loss caused by it or by any use of it.

<p>
<tt><it>*** WARNING *****************************************************</it></tt>

<tt><it>HOTPLUGGING can KILL your hardware.</it></tt>

<tt><it>Do not connect anything to the parallel port while the system or a drive is up.</it></tt>

<tt><it> Always SHUT DOWN, CONNECT, REBOOT.</it></tt>

<tt><it>Again, absolutely NO WARRANTY.</it></tt>

<tt><it>*****************************************************************</it></tt>

<sect1>Supported operating systems<label id="supported-os">

<p>
<it/opencbm/ supports the following operating systems:

<itemize>
<item>For USB based cables: Any Linux, FreeBSD or MacOS X variant that
      support libusb-0.1 should be supported. Linux, FreeBSD and Mac OS X
      have been explicitly tested.
<item>For parallel port based cables:
      Linux 3.x and 2.6 variants. 2.0, 2.2 and 2.4 might still work, but have
      not been tested for ages. For Linux, i386 and AMD64 architectures are
      supported.
<item>For parallel port based as well as USB based cables:
      Windows NT 4.0, 2000, XP and Server 2003, Vista, 7 and 8. For USB based
      cables, NT 4.0 is not supported, though.
      The i386 architecture a.k.a "x86" ("32 bit") is fully supported;
      additionally, 64 bit Windows ("x64", "x86_64") versions are supported.
      Itanium-based Windows ("iA64") are <tt><it/not/</tt> supported,
      though.
</itemize>

<sect1>Supported CBM hardware<label id="supported-drives">

<p>
Currently, opencbm supports the following CBM devices:

<itemize>
<item>VIC 1541, VIC1540 (all variants, including clones)
<item>VIC 1570, VIC 1571 (including the 1571CR and the 1571 inside of a C128DCR)
<item>VIC 1581 (not with d64copy (<ref id="d64copy" name="d64copy">), not with
cbmformat (<ref id="cbmformat" name="cbmformat">) or cbmforng (<ref id="cbmforng" name="cbmforng">))
<item>other CBM IEC drives, printers, and compatibles (only with cbmctrl (<ref
id="cbmctrl" name="cbmctrl">))
<item>VIC 8250, 8050, 4040, 2031, SFD 1001, and possibly other IEEE drives with
an IEC to IEEE converter (for example, IEC2IEEE from Jochen Adler, cf. <htmlurl
url="http://www.nlq.de/" name="http://www.nlq.de/">, or with a ZoomFloppy
extension that lets you use IEEE devices directly.
</itemize>

<sect1>Cables<label id="cable">

<p>
Since the last opencbm release, the PC market has changed considerably. Modern
PCs do not contain parallel ports anymore, nor do they have ISA type connectors
for extension cards. Additionally, parallel port cards connected via PCI, PCIe
or other modern replacements are reported not to work with OpenCBM.

Also, devices that allow you to connect your parallel port printer to the
USB port of your PC cannot work, either.

Thus, there was a need for newer cable replacements. While OpenCBM still
supports parallel port based cables, more modern USB variants are supported,
too, and they should be preferred to the parallel port based ones.

<sect2>USB cables<label id="cable_usb">

<p>
There are two types of USB cables currently supported. The <htmlurl
url="http://www.trikaliotis.net/xu1541" name="XU1541"> cable is a simple cable,
optimised for ease of building and low costs. Its big downside is that
transfers with this cable are very slow. In fact, the parallel port based
solutions for the XA1541 or XM1541 (a.k.a. XAP1541 or XMP1541) were faster than
the XU1541 cable. Thus, it can be recommended only
if you do not plan to use the XU1541 regularly, but only for a limited time.

If you have the money to spend and plan to use your CBM equipment regularly, it
is highly suggested to use a <htmlurl url="abc" name="XUM1541"> cable, for
example, in the incarnation of the <htmlurl url="abc" name="ZoomFloppy">.

Building these cables is beyond the scope of this document. We refer to the
appropriate links on the web for instrutions how to build or order them.

<sect2>Parallel port based cables<label id="cable_pp">
<p>
As parallel ports more and more vanish from modern PC hardware, it is
recommended not to use these cables for new projects, but to use <ref
id="cable_usb" name="USB based cables"> instead.

Another problem for Windows machines is that using such cables requires a
kernel mode driver. For 64 bit Windows machines (with the exception of Win XP
64 bit), in order to load kernel mode drivers, these drivers have to be signed.
Signing a driver not only costs money; it also requires you to have a company in
order to get the needed certificate. Thus, the OpenCBM drivers currently are not
signed, thus, you will
not be able to use parallel port based cables with 64 bit versions of Windows.

This is not completely true, as you can switch off the driver signature
enforcement in windows. Normally, this is used for driver development only.
Use at your own risk! Instructions on disabling the driver signature enforcement
can be found on the web.

These cables are still supported on 32 bit Windows variants, and
they will remain as long as the developers have access to the necessary
infrastructure.

<bf><it/
Please note that USB-to-parallel converters that are designed to let you
access your parallel port based printers on the PC will definitely not work!
If your PC does not have a native parallel port, please consider using an
XU1541 or XUM1541 cable instead!/</bf>

<p>
Also note that a standard X(E)1541 cable won't work with _this_ driver. In
fact, there will probably never be a multitasking OS which works with one of
these, that's why we call it XM1541, M for Multitasking. Anyway, if you have
a XE1541, the necessary modification is simple:

<p>
 <bf>Exchange pins 5 & 6 on the Commodore DIN plug</bf>

<p>
The ACK line is the only line on a PC parallel port that can generate a
hardware interrupt. This way, we get an interrupt when the device releases the
DATA line to signal "ready to receive". Without an interrupt, you would have to
poll for this signal about every 100us, which is inacceptable for any
multitasking system.

Be sure to have your parallel port configured to use an IRQ, usually 7 or 5,
but both are often also used by soundcards.

(ASCII art taken from the StarCommander README :))

<p>
The PC parallel plug (male DB-25 connector):

<tscreen><verb>
        PaperEnd   Busy
    SelectIn   |   |   Ack        Data 7 - Data 0       Strobe
           |   |   |   |   +-------------+-------------+   |
           V   V   V   V   |                           |   V
        +------------------------------------------------------+
        | 13  12  11  10   9   8   7   6   5   4   3   2   1   |
        |  o   o   o   o   o   o   o   o   o   o   o   o   o   |
        +-+                                                  +-+
          |  o   o   o   o   o   o   o   o   o   o   o   o   |
          | 25  24  23  22  21  20  19  18  17  16  15  14   |
          +--------------------------------------------------+
             |                           |   ^   ^   ^   ^
             +-------------+-------------+   |   |   |   |
                        Ground          Select   |   |   AutoFeed
                                              Init   Error
</verb></tscreen>

<p>
The Commodore drive serial bus plug (male 6-pin DIN connector) looks like:

<tscreen><verb>
                                 Reset
                                   |
                                   V
                          +-------+ +-------+
                        +-+       +-+       +-+
                        |     5         1     |
               Data --> |     o    6    o     | <-- SrqIn
                        |          o          |
                        |     4         2     |
                Clk --> |     o    3    o     | <-- Gnd
                        |          o          |
                        +-+                 +-+
                          +-----------------+
                                   ^
                                   |
                                  Atn
</verb></tscreen>


This is the XE1541 cable (won't work with this driver):

<tscreen><verb>
    CBM drive serial port   PC parallel port

        2  Gnd ---------- 18-25  Ground
        3  Atn --------+---- 13  SelectIn
                       +->|-- 1  Strobe
        4  Clk --------+---- 12  PaperEnd
                       +->|- 14  AutoFeed
        5  Data -------+---- 11  Busy
                       +->|- 17  SelectIn
        6  Reset ------+---- 10  Ack
                       +->|- 16  Init
</verb></tscreen>


This is the XM1541 (pins 5 & 6 on the CBM end exchanged)

<tscreen><verb>
    CBM drive serial port   PC parallel port

        2  Gnd ---------- 18-25  Ground
        3  Atn --------+---- 13  SelectIn
                       +->|-- 1  Strobe
        4  Clk --------+---- 12  PaperEnd
                       +->|- 14  AutoFeed
        6  Reset ------+---- 11  Busy	
                       +->|- 17  SelectIn
        5  Data -------+---- 10  Ack
                       +->|- 16  Init
</verb></tscreen>

<p>Besides the XM1541, a XA1541 cable is also supported. That cable consists
of the same connections as the XM1541, but instead of using diodes, it uses
transistors which drive the lines better. Because of this difference, the logic
for outputs is reversed between the XA1541 and the XM1541.

<p>Additionally to the cable types above, opencbm also supports XP1541 and
XP1571 parallel cables, which have to be used <em>in conjunction</em> with the
XM1541 or XA1541 cable.

<p>
For more information about the different supported cables (XM1541, XA1541,
XP1541, XP1571) can be obtained on the Star Commander homepage (<htmlurl
url="http://sta.c64.org/xcables.html" name="http://sta.c64.org/xcables.html">)

<sect>News/Changelog

<p>
<descrip>
<tag/opencbm v0.4.99.99:/

<itemize>
 <item>New tool xum1541cfg, because the old one was severely outdated
</itemize>

<p>
<descrip>
<tag/opencbm v0.4.99.98:/

<itemize>
 <item> TBD @@@
</itemize>

<tag/opencbm v0.4.0:/

<itemize>

 <item>General:
  <itemize>
  <item>Reorganized structure so cbm4win and cbm4linux compile from the same sources
  <item>Fixed many minor and major errors
  <item>Added mnib36 (<htmlurl url="http://rittwage.com/c64pp/dp.php?pg=mnib"
  name="http://rittwage.com/c64pp/dp.php?pg=mnib">) support
  <item><it/cbmforng/: New tool, cf. <ref id="cbmforng" name="cbmforng">
  <item><it/rpm1541/: New tool, cf. <ref id="rpm1541" name="rpm1541">
  </itemize>

 <item>General, Windows specific:
  <itemize>
  <item>Use a free build instead of a checked build. This significantly reduces
  the memory footprint.
  <item>compiles for AMD64, iA64, i386 (Windows only)
  <item>VDD to allow DOS programs to access cbm4win
  <item>new unit file for Delphi, to allow to access cbm4win from Delphi
  <item>New project opencbmvice for debugging with the help of VICE (<htmlurl
  url="http://www.viceteam.org/" name="http://www.viceteam.org/">). For this, a
  special version of VICE is needed.
  </itemize>

 <item>Linux driver:
  <itemize>
  <item>Fixed kernel source directory (Dirk Jagdmann)
  <item>Fixed installation with GNU coreutils head (Dirk Jagdmann)
  <item>Added correct module installation dir for Linux 2.6 (Dirk Jagdmann)
  <item>Added descriptions for module parameters (<it/modinfo cbm/) (Dirk Jagdmann)
  <item>Added "smart reset" for cbm4linux: Delay the reset until all drives are ready.
  </itemize>

 <item>Windows driver:
  <itemize>
  <item>Only access the bus if the parallel port was successfully acquired.
  <item>Added ECP and EPP support into NT4 driver (allowing XP1541 cable to be used there)
  <item>On reset, do not wait a fixed timeout anymore, just wait until all drives are ready again
  </itemize>
 
 <item>instcbm:
  <itemize>
  <item><it/--lock/, <it/--cabletype/: New options
  <item><it/--automatic/ is default now, new option <it/--on-demand/ for old behaviour
  <item>Added <it/-V/ (<it/--version/) command-line option
  <item>Reworked start of driver. It was unloaded and loaded before, which does not make sense
  </itemize>

 <item>cbmctrl:
  <itemize>
  <item><it/cbmctrl popen/, <it/cbmctrl pcommand/ to do ASCII -> PETSCII conversions
  <item><it/cbmctrl status/, <it/cbmctrl dir/: Output the status on stdout, not stderr
  <item><it/cbmctrl lock/, <it/cbmctrl unlock/: New commands
  <item><it/cbmctrl read/, <it/cbmctrl write/: New commands
  <item>Added <it/--version/ and <it/--help/ command-line arguments.
  <item><it/cbmctrl change drive/: New function (heavily based on Joe Forster/STA's "TDCHANGE" from SC, used with permission)
  <item><it/cbmctrl detect/ outputs whether we have a parallel cable
  </itemize>

 <item>cbmcopy:
  <itemize>
  <item>Fixed some timing problems which resulted in hanging in rare cases;
  <item>Cosmetical fix: The device status is written on a separate line on exit.
  <item>Fixed some races between PC and drive code in the transfer functions serial1, serial2, parallel
  <item>New option <it/--transfer=auto/, which is default and finds out the best transfer method for the current setup.
  <item>Do not use $14 in the floppy drive as temporary variable, but $86. This fixes a problem with Rex-DOS.
  <item>Do not trash the file on the PC side if aborted with Ctrl+C.
  </itemize>

 <item>d64copy:
  <itemize>
  <item>Fixed some timing problems which resulted in hanging in rare cases;
  <item><it/--warp/ is default now; New option <it/--no-warp/ for disabling it.
  <item>did not recognize .d71 files as valid images; fixed that.
  <item>Fixed some races between PC and drive code in the transfer functions <it/serial1/, <it/serial2/, <it/parallel/
  <item>New option <it/--transfer=auto/, which is default and finds out the best transfer method for the current setup.
  <item>Do not use $14 in the floppy drive as temporary variable, but $86. This fixes a problem with Rex-DOS.
  <item>Do not trash the file on the PC side if aborted with Ctrl+C.
  </itemize>

 <item>API:
  <itemize>
  <item><tt/cbm_detect_xp1541()/: New function
  <item><tt/cbm_iec_setrelease()/: New function
  <item><tt/cbm_iec_set()/, <tt/cbm_iec_release()/: Extended API to allow setting/resetting more than one line at the same time
  </itemize>

 <item>Build process (Windows):
  <itemize>
  <item>reworked build process (<it/DDKBUILD_START.BAT/)
  <item><it/DDKBUILD_LOCAL.BAT/ contains settings for the CC65 build process, now.
  <item><it/ddkbuild_local.bat.sample/ added as sample for a DDKBUILD_LOCAL.BAT file
  <item><it/postbuild_local.bat.sample/ added as sample for a POSTBUILD_LOCAL.BAT file
  </itemize>

 <item>Build process (Linux):
  <itemize>
  <item>Moved makefiles into LINUX directory; thus, use <it>make -f LINUX/Makefile</it> to compile now.
  </itemize>

</itemize>

<tag/cbm4linux 0.3.3 (NEVER RELEASED!)/
<itemize>
 <item>documentation in <it/--help/ for <it/d64copy/ and <it/cbmcopy/ fixed:
  now, it is clearly stated that a XP cable must be used in combination with a
  serial cable, not as only one. (Spiro Trikaliotis)
 <item>fixed crash with unkown long options in d64copy, cbmformat and maybe cbmcopy
  (Spiro Trikaliotis)
 <item><it/cbmctrl upload/ accepts <it/-/ as filename now (read from stdin)
 <item><it/cbmctrl download/ takes optionally a file name argument (Spiro Trikaliotis)
 <item><it/libd64copy/ failed to recognize .d71 images as valid images. Because of this,
  you could not write a .d71 image back to a real floppy drive
 <item><it/d64copy/: If you copy a disk to an image which already exists, the error
  information was not removed from the file if necessary. This is fixed now.
  (Spiro Trikaliotis)
 <item><it/libd64copy/: Fixed a crash on exit of d64copy if a .d64 file grows.
 <item><tt/parport_enumerate()/-fix for kernels>=2.6.4
 <item>new ioctl <tt/CBMCTRL_CLEAR_EOI/ and API <tt/function cbm_clear_eoi()/ (Robert Norris)
 <item>minor (still compatible) API changes (Spiro Trikaliotis)
 <item><it/cbmformat/: make sure disk name is 0-terminated (Spiro Trikaliotis)
</itemize>

</descrip>

<sect>Installation<label id="installation">

<p>
Depending on the system you are running opencbm on, there are different ways to
install opencbm. Use the appropriate category for you:

<sect1>Quick installation walk-through
<p>
If you want to install OpenCBM as fast as possible, but you are not interested
in the details, just use the instructions from this section and ignore the rest
of this chapter unless you encounter any problems.

If you are more interested for a clean installation, skip this section and read
the rest of this chapter.

<sect2>Linux installation walk-through

<p>
Perform the following steps to install OpenCBM on your Linux machine:

<itemize>
<item>Get the sources from the tarball at <htmlurl
      url="http://www.trikaliotis.net/Download/opencbm-0.4.99.99/opencbm-0.4.99.99-source.tar.bz2"
      name="http://www.trikaliotis.net/Download/opencbm-0.4.99.99/opencbm-0.4.99.99-source.tar.bz2">.
<item>Unpack them into a directory (i.e., <it>&tilde;/opencbm-0.4.99.99</it>, with
      0.4.99.99 being the version number of OpenCBM).
<item><it>cd</it> into the directory: <it>cd &tilde;/opencbm-0.4.99.99</it>
<item>Compile OpenCBM and the appropriate plugin: <it>make -f LINUX/Makefile
opencbm plugin-<em/XXX/</it>, with <it/XXX/ being one of <it/xa1541/, <it/xu1541/ or
<it/xum1541/, depending upon which adapter you are using:
      <itemize>
      <item><bf/XUM1541 + Zoomfloppy only:/ <it>make -f LINUX/Makefile opencbm plugin-xum1541</it>
      <item><bf/XU1541 only:/ <it>make -f LINUX/Makefile opencbm plugin-xu1541</it>
      <item><bf/XA1541 + XM1541 only:/ <it>make -f LINUX/Makefile opencbm plugin-xa1541</it>
      </itemize>
<item>Now, install the OpenCBM package. You must perform this as root, either
by using <it/sudo/, or by explicitly becoming root with <it/su/. The following
command assumes you are using <it/sudo/: <it>sudo make -f LINUX/Makefile
install install-plugin-<em/XXX/</it>, with <it/XXX/ being the same one of
<it/xa1541/, <it/xu1541/ or <it/xum1541/ as above:
      <itemize>
      <item><bf/XUM1541 + Zoomfloppy only:/ <it>sudo make -f LINUX/Makefile opencbm install-plugin-xum1541</it>
      <item><bf/XU1541 only:/ <it>sudo make -f LINUX/Makefile opencbm install-plugin-xu1541</it>
      <item><bf/XA1541 + XM1541 only:/ <it>sudo make -f LINUX/Makefile opencbm install-plugin-xa1541</it>
      </itemize>
<item>Connect your cable (XU1541, XUM1541, XA1541, XM1541) to your CBM IEC
device:
      <itemize>
      <item><bf/XUM1541 + Zoomfloppy + XU1541 only:/ Plug your XU1541 or XUM1541 into the USB port
      <item><bf/XA1541 + XM1541 only:/ Plug your XA1541 or XM1541 cable to the parallel port
      </itemize>
<item>Switch on your CBM IEC device.
<item><bf/XA1541 + XM1541 only:/ Load the kernel module:
	<itemize>
	<item><it>sudo /sbin/depmod -a</it>
	<item><it>sudo /sbin/modprobe parport</it> (this one might fail if you
have the parallelport compiled into the kernel instead of being a module)
	<item><it>sudo /sbin/insmod cbm</it>
	<item>Now, check the file <it>/var/log/messages</it> if your cable was
correctly recognized.
	</itemize>
<item>You are almost done. Check if the command <it/cbmctrl reset/ resets your
drive, or if the command <it/cbmctrl detect/ prints out your device with your
device number. If this works, you are done! If not, please proceed:
<item>If you get an error message that libopencbm cannot be found, you must add
it to your linker path. In order to do so, enter the command <it>make -f
LINUX/Makefile ldconfig</it>
<item>Now, everything should be working, and you should be able to use the
OpenCBM tools even as non-root.
</itemize>

<sect2>Mac OS X installation walk-through

<p>
Please check the instructions at <htmlurl
url="http://lallafa.de/blog/c64-projects/opencbm-on-mac/"
name="http://lallafa.de/blog/c64-projects/opencbm-on-mac/"> available on the
blog of Christian Vogelgsang, who actually ported OpenCBM to the Mac. His site
should be your primary source for instructions.

<sect2>Windows installation walk-through

<p>
You need the Windows binaries from <htmlurl
url="http://www.trikaliotis.net/Download/opencbm-0.4.99.99/opencbm-0.4.99.99.zip"
name="http://www.trikaliotis.net/Download/opencbm-0.4.99.99/opencbm-0.4.99.99.zip"> in order to install OpenCBM.

<p>
For Windows, you have to install the USB drivers first if you want to use the ZoomFloppy, XUM1541 or XU1541 devices.

<sect3>USB driver installation

<p>
For previous version of OpenCBM and 64 bit versions of Windows, that meant you had to fiddle around with the
driver signature enforcement in order to get this done.

For v0.4.99.99, we rely on an external tool which makes it much easier for you.

Please proceed as follows:

<itemize>
<item>Attach your XUM1541/ZoomFloppy or XU1541 device to your PC via USB.
<item>Download the zadig tool from <htmlurl url="http://zadig.akeo.ie/" name="http://zadig.akeo.ie/">.
Note that there are different versions for Windows XP and later versions for Windows; download the appropriate one!
<item>Unpack the tool in a directory and start it. You might get an UAC prompt (Vista and later, <ref id="zadig-uac">), which you must confirm.
<item>You should see your USB device (XUM1541, XU1541) mentioned in the screen.
If you do not, please select, <ref id="zadig-listalldevices">. This is
especially true if you installed the drivers for the USB device before.
<item>Now, adjust some settings.
      <itemize>
      <item><bf/XUM1541 + ZoomFloppy only:/ Make sure that zadig tells you it found the "xum1541 floppy adapter", and that it
      wants to install the libusb-win32 driver. The USB id is 16D0 (vendor) and 0504 (product). 
      Your screen should look like figure <ref id="zadig-xum1541">.
      <item><bf/XU1541 only:/ Make sure that zadig tells you it found the "xu1541", and that it
      wants to install the libusb-win32 driver. The USB id is 0403 (vendor) and C632 (product).
      Your screen should look like figure <ref id="zadig-xu1541">.
      </itemize>
<item>Now, press "install driver".
<item>Wait until you get the message "The driver was installed successfully." <ref id="zadig-success">
</itemize>

<it><bf/Note:/ zadig does not rely on the OpenCBM files at all! Specifically, it contains its own version of the
USB drivers embedded into the executable; thus, you do not have to specify a link to the driver files,
or put them at a specific location. Just use it "as is".</it>

<figure>
<eps file="zadig-uac.eps">
<img src="zadig-uac.png">
<caption>UAC for zadig which must be confirmed<label id="zadig-uac"></caption>
</figure>

<figure>
<eps file="zadig-listalldevices.eps">
<img src="zadig-listalldevices.png">
<caption>Enable "List all devices" for zadig<label id="zadig-listalldevices"></caption>
</figure>

<figure>
<eps file="zadig-xum1541.eps">
<img src="zadig-xum1541.png">
<caption>zadig settings for installing an xum1541 device<label id="zadig-xum1541"></caption>
</figure>

<figure>
<eps file="zadig-xu1541.eps">
<img src="zadig-xu1541.png">
<caption>zadig settings for installing an xu1541 device<label id="zadig-xu1541"></caption>
</figure>

<figure>
<eps file="zadig-success.eps">
<img src="zadig-success.png">
<caption>zadig message that it installed the driver successfully<label id="zadig-success"></caption>
</figure>

Now, proceed with installation the OpenCBM tools.

<sect3>OpenCBM tool installation

<p>
In order to install OpenCBM, proceed as follows:

<itemize>
<item>Download the OpenCBM package binary for Windows from <htmlurl
      url="http://www.trikaliotis.net/Download/opencbm-0.4.99.99/opencbm-0.4.99.99.zip"
      name="http://www.trikaliotis.net/Download/opencbm-0.4.99.99/opencbm-0.4.99.99.zip">
      Note that unlike previous versions of OpenCBM, v0.4.99.99 now contains one package for
      all supported architectures (i386 vs. amd64, 32 bit vs. 64 bit). You do not have to
      choose which one to get.
<item>Unpack it into a directory of your liking
<item>Start a cmd.exe shell as administrator. The exact procedure varies among the different Windows versions.
<item>Go to the directory where you unpacked the OpenCBM installation package (with the "cd" command)
<item>Enter<itemize>
      <item><bf/ZoomFloppy only:/ <it/install zoomfloppy/ (this is also default, that it, it suffices if you enter <it/install/ only)
      <item><bf/XUM1541 only:/ <it/install xum1541/
      <item><bf/XU1541 only:/ <it/install xu1541/
      <item><bf/XA1541 only:/ <it/install xa1541/
      </itemize>
<item>If you want to use the OpenCBM tool whenever you are in the cmd.exe
      shell, you have to add the directory that is printed in the last line of
      the install.cmd output to your PATH environment variable. In many cases,
      it will be C:\Program Files\OpenCBM.
</itemize>

<sect1>Installing opencbm on Mac OS X (USB cable)<label id="cbm4mac-install">

<p>
For Mac OS X, there are <htmlurl
url="http://lallafa.de/blog/c64-projects/opencbm-on-mac/" name="special
installation instructions"> available on the blog of Christian Vogelgsang, who
actually ported OpenCBM to the Mac. His site should be your primary source for
instructions.

<sect1>Installing opencbm on Linux or FreeBSD<label id="cbm4linux-install-all">

<p>
The installation of OpenCBM differs a little bit depending on the cable used to
connect your CBM equipment. The following instructions try to show the
installation procedure as straight-forward as possible.
At first, I will describe the prerequisites for each cable type. Afterwards, I
will describe the installation bits that are common to all cable types.
At last, I will describe some special postprocessing steps that are needed for
some cable types.

<sect2>Prerequisites

<sect3>XUM1541 cable (a.k.a. ZoomFloppy) and XU1541 cable

<p>
These two cables are rather easy. In order to compile them, you need the libusb
packages (libusb 0.1, <it/not/ 1.0) and the corresponding libusb development
package. For Debian based systems, it is enough to install the package
`libusb-dev'.

<sect3>XA1541 cable or XM1541 cable

<p>
The XA1541 cable and the XM1541 cable need a kernel module (cbm.o) which acts
as a driver for the parallel port based cables.

<p>
The kernel module (cbm.o) does not require any kernel patches and should
compile right out of the box, at least with kernel 3.x and 2.6.x, but 2.0.x,
2.2.x and 2.4.x might still work as well. They have not been tested in ages,
though, thus, you are on your own.

<p>
In order to compile the kernel module, you will need the headers that
correspond to your current running kernel. For debian-based systems, you can
accomplish this by running <it/aptitude install linux-headers-`uname -r`/ as
root.


<sect3>Any cable type
<p>
If you intend to modify the drive routines for `d64copy' and `cbmformat' you
also need a crossassembler. `opencbm/LINUX/config.make' comes with rules for Ullrich
von Bassewitz' `cl65' (comes
with cc65, <htmlurl url="http://www.cc65.org/" name="http://www.cc65.org/">).
Starting with version cbm4linux 0.2.3, opencbm includes precompiled 6502
binaries, so as long as you don't touch the .a65 files, there's no need for a
crossassembler.

This package comes with a .spec file for those who want to build binary .RPMs.
See the RPM documentation (outside of this paper) for details about the build
process. Additionally, all files needed to built Debian .DEB packages are
included. If you upgrade from a previous (non-RPM and non-DEB) version and want
to install a packetized binary version (RPM or DEB), don't forget to remove the
old files hanging aroung (just do "<it/make uninstall/", preferably in the
*old* source directory. For a >= 0.4.0 version of opencbm, change the line to
"<it>make -f LINUX/Makefile uninstall</it>".).

<sect2>Compile-time configuration
<p>
The compile-time configuration is located in `opencbm/LINUX/config.make'. Check the
KERN_FLAGS line if you're running kernel 2.0.x or if you don't want to use the
Linux parport subsystem for some reason. Same goes for SMP machines.


<sect2>Compilation

<p>
<itemize>
<item>Type <it>make -f LINUX/Makefile opencbm plugin-XXX</it>    (no root privileges required)

(replacing XXX with either xum1541, xu1541 or xa1541, depending upon the cable
type you are using)

to build OpenCBM, which includes the libraries and utility programs (no
root privileges required).

Example: In case you are compiling for the xum1541 cable, use <it>make -f
LINUX/Makefile opencbm plugin-xum1541</it>

<item>If you are using an XA1541 or XM1541 cable, issue <it>make -f LINUX/Makefile dev</it>    (as root)

to   create   the  character  device "/dev/cbm" with major 10 and
minor 177 (this number is registered,  so  it  shouldn't  collide
with anything else :)).

<item>Finally, install everything by running <it>make -f LINUX/Makefile
install install-plugin-XXX</it>     (as root)

again replacing XXX with xum1541, xu1541 or xa1541, depending upon the cable
type you are using.

This will  install  all  necessary  stuff  to  /usr/local/...  (can be
changed in `opencbm/LINUX/config.make')
</itemize>

<sect2>Loading the module (XA1541/XM1541 only)

<p>
<bf/This is only needed if you are using the XA1541 or XM1541 cables. Otherwise, skip this section/
<p>
If  you're  using  the  parport subsystem (which is default), you
should now be able to load the driver module by issuing (as root)

<p>
<itemize>
<item><it>/sbin/depmod</it>
<item><it>/sbin/modprobe parport</it>      (unless compiled into the kernel)
<item><it>/sbin/insmod cbm lp=</it>your_lp   (usually 0, which is default)
</itemize>

<p>
or, when built with -DDIRECT_PORT_ACCESS:

<p>
<itemize>
<item><it>/sbin/insmod cbm port=your_ioport irq=your_irq</it>
(default is 0x378 for port, 7 for irq)
</itemize>

Check <tt>/var/log/messages</tt> if the correct cable type was recognized
(XA1541/XM1541).


<sect2>udev rules so that you can access the cables as non-root user (Linux only)
<p>
Normally, you will have access to your device only if you are logged in as root,
or if you use <it/sudo/.
You might want to change this behaviour. For this, OpenCBM includes udev rules
that allow you to customize who is able to access the devices.

These files are located in:
<itemize>
<item><it>opencbm/sys/linux/45-opencbm-xa1541.rules</it> (for XA1541/XM1541
cables)
<item><it>xu1541/udev/45-opencbm-xu1541.rules</it> (for XU1541 cables)
<item><it>xum1541/udev/45-opencbm-xum1541.rules</it> (for XUM1541 cables)
</itemize>

<p>
The appropriate file(s) are copied into the directory
<it>/etc/udev/rules.d/</it> at installation time. They will allow any member of
the group <it/user/ to use the corresponding cable.

If you want to use another group, just change the files accordingly.

<sect2>Troubleshooting

<p>
Finding the cause of a failure condition can be hard. Anyway, the
following tips might help you:

<itemize>
<item>Check <tt>/var/log/messages</tt>; it might give you some hints.

<item>For XU1541 and XUM1541 cable:
<itemize>
<item>Did you install libusb? You need v0.1, a v1.0 libusb will not work unless
you install the v0.1 compatibility layer, too.
</itemize>

<item>For XA1541 and XM1541 cable:
<itemize>
<item>If you are using the parport subsystem (no -DDIRECT_PORT_ACCESS):

<itemize>
<item>the port might be occupied by another device (e.g. `lp.o')
     cbm.o does NOT support port sharing (wouldn't work anyway).
     Enter <it>cat /proc/parport/port/devices</it> to find out.

<item>parport_pc might not use an IRQ.
     <it>/etc/modules.conf</it> should contain something like:
     <tscreen><verb>
       alias parport_lowlevel parport_pc
       options parport_pc io=0x378 irq=7
     </verb></tscreen>
     Check the interrupts with <it>cat /proc/interrupts</it>.
</itemize>

<item>Using direct port access (with -DDIRECT_PORT_ACCESS):

<itemize>
<item>The port/IRQ might occupied by another driver (e.g. parport.o)
     Enter <it>cat /proc/interrupts</it> and <it>cat /proc/ioports</it> to find
     out.
</itemize>
</itemize>
</itemize>


<sect2>Device access

<p>
As a first test, try something simple like

<itemize>
<item><it/cbmctrl command 8 I0:/    (assuming drive 8)
<item><it/cbmctrl status 8/
</itemize>

<p>
(no root privileges required)

<p>
Failure can be caused by:
<itemize>
<item>Possibly, the shared library in <tt>/usr/local/lib/</tt> cannot be found;
in this case, add <tt>/usr/local/lib/</tt> to <tt>/etc/ld.so.conf</tt> and
execute <it/ldconfig/ (as root).
<item>You might not have the necessary rights to the <tt>/dev/cbm</tt> device;
try <it>chmod 777 /dev/cbm</it>
<item>incorrect module parameters
<item>wrong BIOS settings (esp. IRQ)
<item>broken cable
</itemize>

<sect2>Runtime configuration (Applies to XA1541 and XM1541 cables only!)

<p>
Most probably, you will want to add this to <tt>/etc/modules.conf</tt> to have
the driver loaded on demand: (the file is called <tt>/etc/conf.modules</tt> on
some older SuSE systems)

<tscreen><verb>
    alias char-major-10-177 cbm
    options cbm [options]
</verb></tscreen>

With [options] being one or more of:

<itemize>
<item><it/lp=*lp*/       (parport only, as used in <it>/sbin/insmod</it> above)
<item><it/irq=*irq*/     (direct port only, as used in <it>/sbin/insmod</it> above)
<item><it/port=*port*/   (direct port only, as used in <it>/sbin/insmod</it> above)
<item><it/cable=*n*/      force cable type:
 <itemize>
 <item>               -1  for autodetection (default)
 <item>                0  for XM1541 (non-inverting)
 <item>                1  for XA1541 (inverting)
 </itemize>
<item><it/reset=*n*/     initializing behaviour:
 <itemize>
 <item>               -1  smart IEC reset (direct port default);
                          only change the status of the reset line if it was set on start
 <item>                0  no IEC reset on driver start
 <item>                1  force IEC reset (parport default);
                          always reset the device on driver start
 </itemize>
</itemize>

<p>
Congratulation, you have successfully set up your opencbm installation!


<sect1>Installing opencbm on Windows (cbm4win)<label id="opencbm-install">

<p>
<it/WARNING! If you have already installed a previous version of OpenCBM on your
machine, you have to uninstall it before installing a new version. For this, go
to the directory where the old (!) version is located, and enter instcbm
--remove./

First of all, Windows must know about the driver. For this, we must install it
with the instcbm tool. This is done as follows:

<itemize>
<item>Make sure you have a supported operating system up and running.

<item>You need administrator privileges on the Windows machine to perform the
following actions.

<item>At first, you have to make sure you have the needed hardware ready. Do the
following:

<itemize>
<item>Get your supported drive <ref id="supported-drives" name="supported drive">.

<item>Moving cables with equipment turned on can damage either your PC,
and/or the drive, so, be carefull!

<item>Thus, switch off your PC and your VIC 15xx drive!

<item>Connect your XA1541 or XM1541 cable to your PC. If you have a parallel
port cable (XP1541), connect that one, too.

<item>Connect your VIC 15xx floppy drive to the cable

<item>Switch on the PC.
</itemize>

<item>Just download the binary package, and unpack it into an arbitrary
directory.

<item>Get a command-line (Start/Run, and type "<it/cmd.exe/"), change into the
directory you unpackaged the drivers into (with "<it/cd/").

<item>Type "<it/cd exe/"

<item>The next step depends upon the cable type you are using.
 <itemize>
   <item>If you are using an XUM1541 cable (a.k.a. ZoomFloppy), type "<it/instcbm xum1541/"
   <item>If you are using an XU1541 cable, type "<it/instcbm xu1541/"
   <item>If you are using an XA1541 or XM1541 cable, type "<it/instcbm xa1541/"
 </itemize>
<item>In any case, check the outputs of the <it/instcbm/ command. Its last line should look like
<it/No problems found in current configuration/. In this case, you are done. In
some rare cases, <it/instcbm/ will suggest a reboot, which you should follow.

<item>You might want to have a look at the possible options for instcbm. They
are available by typing "<it/instcbm --help/". Also, cf. <ref id="instcbm"
name="instcbm">.

<item>If you had to reboot in the previous step, do the following:

<itemize><item>Go to a command-line, and change into the directory you
unpackaged the drivers into again.

<item>Type "<it/cd exe/"
</itemize>
</itemize>

<sect>Checking if the installation is complete
<p>
After you installed opencbm (cf. <ref id="installation" name="Installation">,
it is wise to check if the installation works as expected. For this, do the
following:

<itemize>
<item>Switch on the floppy drive. Depending on the type of
cable you are using (XA1541 or XM1541) and the parallel port of your PC, the
drive might keep spinning endless now, because it is continuously resetted.

<item>Type "<it/cbmctrl reset/" and press enter. If it does not already, the red
floppy drive LED should light up, and the drive should start spinning. After
approximately one second (up to five seconds in the case of a 1581), the red
LED should switch off again, and the drive stops spinning.

<item>Type "<it/cbmctrl status 8/" to get the status (error) code from the
attached floppy drive. If everything works fine, your drive should answer with
its identification string. For a 1541, this is something like <it/73,cbm dos v2.6
1541,00,00/, while for a 1571, this line looks like <it/73,cbm dos v3.0
1571,00,00/.
There might also be some variant of this line, depending on the firmware version
of your drive.

<item>Type "<it/cbmctrl status 8/" to get the status (error) code from the floppy
drive again. As the power on message has been read, your drive should answer with a
<it/00, ok,00,00/ string.

<item>Type "<it/cbmctrl detect/". This command tries to detect the types of drive
which are connected on the cable. You should see the drive which you posess.

<item>We want to check if we can send anything to the floppy drive. Remove
any diskette from the drive and press "<it/cbmctrl open 8 15 I0/". (Make sure the "I"
is an upper-case "I". A lower-case "I" will not work!) This command tries to
initialize the disk. Anyway, since there isn't a disk in the drive, an error
occurs. You should hear the floppy spinning, and in case of a 1541, the R/W-head
should start bumping. After some seconds, the red LED starts starts flashing,
indicating that an error occurred.

<item>Try again "<it/cbmctrl status 8/" to get the status (error) code from
the floppy drive. As an error occurred before, an error string should be
displayed. For my setup, it is the "<it/21,read error,18,00/" string. Furthermore,
the red LED should stop flashing.
</itemize>

If you have come so far, you are sure that you send commands to the floppy, and
receive answers from it. This is very good so far. Furthermore, don't panic:
you do not have to enter these commands over and over again, these are only
tests to make sure that anything is correctly installed.

If you have a D64 file or a floppy disk ready, you can try
transferring it over the cable. Do not use all of the following commands, but
only the ones you want to perform.

<itemize>
<item>If you want to transfer an existing floppy from the drive to the PC, use
the following command: "<it/d64copy 8 A.D64/", while replacing A.D64 by the
name you want to give to the file.

<item><bf>WARNING THE FOLLOWING COMMAND OVERWRITES ANYTHING THAT WAS ON THE FLOPPY
BEFORE, so make sure you do not need that floppy anymore.</bf>

If you have a D64 or D71 on your PC, and you want to write it to a new, already
formatted disk, enter "<it/d64copy A.D64 8/" if the file is called A.D64.

<item><bf>WARNING THE FOLLOWING COMMAND OVERWRITES ANYTHING THAT WAS ON THE FLOPPY
BEFORE, so make sure you do not need that floppy anymore.</bf>

If you have a disk you want to format, you have two options: Either use the
command "<it/cbmctrl command 8 N0:NAME,ID/", or use the cbmformat program, cf.
<ref id="cbmformat" name="cbmformat">, or the cbmforng program, cf. <ref
id="cbmforng" name="cbmforng">.
</itemize>

<p>
You can have a look at the available cbmctrl commands by issuing cbmctrl on
your command line, or look at <ref id="cbmctrl" name="cbmctrl">. For the other
programs, you get help by issuing the "--help" option, or look at the
appropriate section in <ref id="utilities" name="utilities">.

<sect>Uninstall<label id="installation">

<p>
Depending on the system you are running opencbm on, there are different ways to
uninstall opencbm. Use the appropriate category for you:

<sect1>Quick uninstallation walk-through
<p>
If you want to uninstall OpenCBM as fast as possible, but you are not interested
in the details, just use the instructions from this section and ignore the rest
of this chapter unless you encounter any problems.

If you are more interested in a clean uninstallation, skip this section and read
the rest of this chapter.

<sect2>Linux uninstallation walk-through

<p>
Perform the following steps to uninstall OpenCBM on your Linux machine:

<itemize>
<item>I assume you already have an installation directory for OpenCBM handy.
      Let's assume it is <it>&tilde;/opencbm-0.4.99.99</it>, with
      0.4.99.99 being the version number of OpenCBM.
<item><it>cd</it> into the directory: <it>cd &tilde;/opencbm-0.4.99.99</it>
<item>Enter: <it>sudo make -f LINUX/Makefile uninstall</it>
<item>Now, everything should be uninstalled.
</itemize>

<sect2>Mac OS X uninstallation walk-through

<p>
Please check the instructions at <htmlurl
url="http://lallafa.de/blog/c64-projects/opencbm-on-mac/"
name="http://lallafa.de/blog/c64-projects/opencbm-on-mac/"> available on the
blog of Christian Vogelgsang, who actually ported OpenCBM to the Mac. His site
should be your primary source for instructions.

<sect2>Windows uninstallation walk-through

<p>
In order to uninstall OpenCBM, proceed as follows:

<itemize>
<item>If you <bf/did/ follow the quick installation walk-through:
  <itemize>
  <item>Go to the control panel, select <it/Programs/, and have a look at the list of installed programs <ref id="opencbm-software-installed">.
  <item>Right-click on the entry "OpenCBM", and select "uninstall" <ref id="opencbm-software-installed-uninstall">.
  <item>If you added the OpenCBM installation directory to your path, you should undo this.
  </itemize>

<item>If you did <bf/not/ follow the quick installation walk-through:
  <itemize>
  <item>Open a cmd.exe shell with administrator privileges.
  <item><it/cd/ into the directory where OpenCBM is installed.
  <item>Enter <it/instcbm --remove/ to uninstall OpenCBM.
  <item>If you added the OpenCBM installation directory to your path, you should undo this.
  </itemize>
</itemize>

<figure>
<eps file="opencbm-software-installed.eps">
<img src="opencbm-software-installed.png">
<caption>OpenCBM as installed program on Windows<label id="opencbm-software-installed"></caption>
</figure>

<figure>
<eps file="opencbm-software-installed-uninstall.eps">
<img src="opencbm-software-installed-uninstall.png">
<caption>Uninstall OpenCBM from Windows<label id="opencbm-software-installed-uninstall"></caption>
</figure>


<sect>Utilities<label id="utilities">

<p>
As the kernel driver is quite useless for itself, the following utility
programs are included with this package:

<itemize>
<item><it/cbmctrl/ (cf. <ref id="cbmctrl" name="cbmctrl">)

 command line utility for direct device access at talk/listen level.

<item><it/cbmformat/ (cf. <ref id="cbmformat" name="cbmformat">)

 fast 1541 disk formatter (for 1541, 1570 and 1571 drives).

<item><it/cbmforng/ (cf. <ref id="cbmforng" name="cbmforng">)

 fast 1541 disk formatter (for 1541, 1570 and 1571 drives).

<item><it/d64copy/ (cf. <ref id="d64copy" name="d64copy">)

 copies .d64 images to 1541 compatible drives and vice versa. Type `d64copy -h'
 to get a list of valid options. Use the device number to address the disk
 drive, e.g. `d64copy -t serial2 8 img.d64'.

 This version contains the StarCommander Turbo and Warp routines and custom
 transfer routines as well as parallel cable (XP1541) support. These are the
 benchmarks for Michael Klein's old Pentium-200/MMX system (seconds)

 <tscreen><verb>
 mode               write     read

 parallel turbo     54.02    53.30
 parallel warp      32.47    29.56
 serial1 turbo     168.59   168.58
 serial1 warp      183.57   158.87
 serial2 turbo      95.02    95.26
 serial2 warp       88.29    80.57
 </verb></tscreen>

<item><it/d82copy/ (cf. <ref id="d82copy" name="d82copy">)

 Like <ref id="d64copy" name="d64copy">, but for d80 and d82 images with a CBM
 8250 drive or compatibles.

<item><it/imgcopy/ (cf. <ref id="imgcopy" name="imgcopy">)

 Tries to integrate the functionality of <ref id="d64copy" name="d64copy"> and
 <ref id="d82copy" name="d82copy"> into one generic application.

<item><it/cbmcopy/ (cf. <ref id="cbmcopy" name="cbmcopy">)

 fast 1541/1570/1571/1581 file copier.

<item><it/rpm1541/ demo (cf. <ref id="rpm1541" name="rpm1541">)

 determines the drive rotation speed of 1541, 1570 and 1571 drives.

<item><it/flash/ demo (cf. <ref id="flash" name="flash">)

 flashes the LED of 1541, 1570 and 1571 drives.

<item><it/morse/ demo (cf. <ref id="morse" name="morse">)

 morses arbitrary texts with the help of the LED of 1541, 1570 and 1571 drives.

<item><it/cbmlinetester/ debugging aid (cf. <ref id="cbmlinetester"
 name="cbmlinetester">)

 is a debugging aid which helps you set the IEC lines to specific values
 and read out the current state of the lines.

</itemize>

<sect1>instcbm (Windows only)<label id="instcbm">

<p>
<it/instcbm/ is used on Windows to install the opencbm driver.

<em/Please note that the syntax of instcbm has changed considerably in v0.4.99.99
with respect to the syntax used until version v0.4.2!/

<sect2>instcbm invocation<label id="instcbm command structure">
<p>Synopsis: <tt>instcbm {<it/[global-options]/ <it/[plugin]/
<it/[plugin-options]}*/</tt>

<p>Where the following <it/[global-options]/ are possible:
<descrip>
<tag/-h, --help/
display help and exit.

<tag/-V, --version/
display version information about OpenCBM.

<tag/-r, --remove/
remove (uninstall) the driver.

<tag/-u, --update/
update parameters if driver is already installed. 

<tag/-n, --nocopy/
do not copy the driver files into the system directory. This is not recommended.

<tag/-c, --check/
only check if the installation is ok. Do not install or uninstall anything.

<tag/-@, --adapter=[plugin]/
Define the specified plugin as default plugin.

</descrip>

<p>
The <it/[plugin]/ is one of <it/xa1541/, <it/xu1541/ or <it/xum1541/. For each
plugin, there are plugin specific options possible.

<p>
For the <it/xa1541/ plugin, the following <it/[plugin-options]/ are possible:
<descrip>
<tag/-h, --help/
display help and exit.

<tag/-V, --version/
display version information about the xa1541 plugin.

<!--
<tag/-e, -enumpport/
re-enumerate the parallel port driver.
-->

<tag/-l, --lpt=*no*/
set default LPT port to number <it/*no*/. For example, for LPT2, use <it/--lpt=2/.

If not specified, or <it/--lpt=0/ is specified, use the first parallel port.

<tag/-t, --cabletype=*TYPE*/
set cabletype to <it/*TYPE*/, which can be <it/auto/, <it/xa1541/ or <it/xm1541/.

If not specified, <it/--cabletype=auto/ is assumed.

<tag/-L, --lock=*WHAT*/
automatically lock the driver. <it/*WHAT*/ can be <it/yes/ (automatically lock)
or <it/no/ (do not automatically lock).

If not specified, <it/--lock=yes/ is assumed.

<tag/-F, --forcent4/
force the NT4 driver on a Win 2000, XP, or newer systems (NOT RECOMMENDED!).
This option is only available on i386 architectures; AMD64 and iA64 do not support it.

<tag/-A, --automatic/
(default) automatically start the driver on system boot.

The driver can be used from a normal user, no need for administrator rights.
The opposite of <it/--on-demand/.

<tag/-O, --on-demand/
start the driver only on demand.

The opposite of <it/--automatic/.
</descrip>

<p>
For the <it/xu1541/ plugin, the following <it/[plugin-options]/ are possible:
<descrip>
<tag/-h, --help/
display help and exit.

<tag/-V, --version/
display version information about the xu1541 plugin.
</descrip>

<p>
For the <it/xum1541/ plugin, the following <it/[plugin-options]/ are possible:
<descrip>
<tag/-h, --help/
display help and exit.

<tag/-V, --version/
display version information about the xum1541 plugin.
</descrip>



<sect2>instcbm Examples<label id="instcbm examples">

<p>
Install the XA1541/XM1541 driver and the DLL on the machine. The driver and the DLL
are copied into the Windows system directory, so opencbm can be used from
every program:
<code>
instcbm xa1541
</code>

<p>
Install the driver, like above. Additionally, specify that you
are using an XM1541 cable:
<code>
instcbm xa1541 --cabletype=xm1541
</code>

<p>
Check if the installation was set up successfully:
<code>
instcbm --check
</code>

<p>
Install OpenCBM ready for use with the XU1541 cable:
<code/instcbm xu1541/

<p>
Install OpenCBM ready for use with the XUM1541 (a.k.a. ZoomFloppy) cable:
<code/instcbm xum1541/

<p>
Install OpenCBM for all the XA1541, XU1541 and XUM1541 cables at once, making
the xum1541 cable the default adapter:
<code/instcbm xum1541 xu1541 xa1541/ or, equivalent: <code/instcbm --adapter=xum1541/

<p>
Change the default adapter after OpenCBM was already installed:
<code/instcbm --update --adapter=xa1541/

<p>
Remove the driver including <em/all/ plugins from the system. You will not be
able to use opencbm after this command, unless you re-install it. If files were
copied into the Windows system directory, they will be removed:
<code>
instcbm --remove
</code>

<p>
After opencbm has been installed (with <it/instcbm/>), change the parallel
port to be used to 2:
<code>
instcbm --update xa1541 --lpt=2
</code>

<p>
Install opencbm, directly specifying LPT3 as the parallel port to use:
<code>
instcbm xa1541 --lpt=3
</code>

<p>
Install the DLL and the driver on the machine. Do not copy the files to the
Windows system directory, but leave them "where they are". If you use this
option, the directory where your files resides must be accessible for the
system while booting. For example, network drives, USB drives or FireWire
drives are not allowed.
<code>
instcbm --nocopy
</code>

<sect1>cbmctrl<label id="cbmctrl">

<p><it/cbmctrl/ is used to send commands to external devices. It can
control all kinds of serial CBM devices like floppy drives and printers. So
far, it has been successfully tested with the disk drives 1541(-II), 1571
and a MPS-1200 printer.

<sect2>Command structure<label id="cbmctrl command structure">
<p>The overall format of all <it>cbmctrl</it> actions is:

<p>Synopsis: <tt>cbmctrl <it>[global_options] </it>ACTION <it>[action_args]</it></tt>
<descrip>
<tag>global_options</tag>
<p>Some options that are related to <it>cbmctrl</it> in general of which affect
the oervall behaviour of all actions
<tag>action</tag>
<p>One of a bunch of different subcommands that direct <it>cbmctrl</it> what to do
<tag>action_args</tag>
<p>Arguments that are required for the subcommand <it>action</it> to work
</descrip>

<sect3>Global options<label id="cbmctrl global options">
<p><it>cbmctrl</it> understands the following global options

<descrip>
<tag>-h <it>[ACTION]</it>, --help <it>[ACTION]</it></tag>
<p>Outputs the help screen with a short listing of all available actions. If
the optional <it>ACTION</it> name is given also, you retrieve more information
on a special action together with its arguments and parameters
<tag>-V, --version</tag>
<p>Output version information as well as the built date and time
<tag/-@, --adapter=&lt;plugin&gt;[:&lt;bus&gt;]/
<p>Specify the plugin to use. If you have installed more than one plugin
(XA1541, XU1541, XUM1541), you can specifiy which one to use for this command.
This way, you can use all three variants at the same time.

This requires an argument of the form &lt;plugin&gt;[:&lt;bus&gt;], where
&lt;plugin&gt; is the plugin's backend name (currently: <it/xa1541/,
<it/xu1541/, <it/xum1541/), and &lt;bus&gt; is the bus identifier, if it is
supported by the backend.

<tag>-f, --forget</tag>
<p>Future extension, unused at the moment
<tag>-p, --petscii (default for all actions but <it>open</it> and
<it>command</it>)</tag>
<p>Convert input or output parameter from CBM format (PETSCII)

When specifying texts to be sent to the floppy or when receiving
texts from the floppy, convert them from/to petscii before outputting.
This way, small letters on the PC side are small letters on the CBM side.
The opposite is -r, --raw.
<tag>-r, --raw (default for <it>open</it> and <it>command</it></tag>
<p>Do not convert data between CBM and PC side.

</descrip>

<sect3>Actions overview<label id="cbmctrl actions overview">
<p><it>cbmctrl</it> understands the following subcommand actions
<descrip>
<tag>reset</tag>
<p>Reset all drives on the IEC bus
<tag>detect</tag>
<p>Detect all drives on the IEC bus
<tag>lock</tag>
<p>Lock the parallel port for opencbm (cbm4linux/cbm4win) use
<tag>unlock</tag>
<p>Unlock the parallel port from exclusive usage
<tag>listen</tag>
<p>Perform a listen on the IEC bus
<tag>talk</tag>
<p>Perform a talk on the IEC bus
<tag>unlisten</tag>
<p>Perform an unlisten on the IEC bus
<tag>untalk</tag>
<p>Perform an untalk on the IEC bus
<tag>open</tag>
<p>Perform an open on the IEC bus
<tag>popen</tag>
<p>Same as open, but with ASCII to PETSCII conversion.
Its use is deprecated, use the global option --petscii with <it>open</it>
instead.
<tag>close</tag>
<p>Perform a close on the IEC bus
<tag>read</tag>
<p>Get a stream of raw data from an IEC bus device
<tag>write</tag>
<p>Put a stream of raw data to an IEC bus device
<tag>put</tag>
<p>Put specified data to the IEC bus device.
In contrast to <it>write</it>, it allows you to specify the data as decimal,
hexadecimal or octal values.
<tag>status</tag>
<p>Give the status of a specified drive
<tag>command</tag>
<p>Issue a command to a specified drive
<tag>pcommand</tag>
<p>Same as command, with ASCII to PETSCII conversion
Its use is deprecated, use the global option --petscii with <it>command</it>
instead.
<tag>dir</tag>
<p>Output the directory of a disk in a specified drive
<tag>download</tag>
<p>Download memory contents from a floppy drive
<tag>upload</tag>
<p>Upload memory contents to a floppy drive
<tag>change</tag>
<p>Wait for a disk to be changed in a specified drive
</descrip>

<sect3>Common action arguments<label id="cbmctrl common action arguments">
<p>Many of the <it>cbmctrl</it> subcommands understand the following common
arguments:
<descrip>
<tag>[DEVICE]</tag>
<p>Advice <it>cbmctrl</it> to direct its communication to the IEC bus device
with the number <it>[DEVICE]</it>. IEC bus device numbers can be denoted in
the range from 0 to 30, although no Commodore device is known to use device
numbers 0 to 3. Most commonly used are the numbers 4 (printer) and 8 to 11
(disk drives). Device number 31 is used to denote the UNTALK respectively the
UNLISTEN command code on the IEC bus instead of the TALK respectively LISTEN
command code, therefore device address 31 cannot be used in general.
<tag>[SECADR]</tag>
<p>With several <it>cbmctrl</it> actions the secondary address parameter
<it>[SECADR]</it> denotes a dedicated logical communication channel for the
specifed <it>[DEVICE]</it> . IEC bus channel numbers can be denoted in the
range from 0 to 15. Take note that for floppy disk drive devices some
secondary addresses are interpreted in a special way. Secondary address 0 is
used, when a program is loaded, address 1, when a program is saved. Address
number 15 represents the command channel of the disk drive, so effectively,
for bulk data transfers to and from disk drives, only the logical channel
numbers 2 to 14 can be used.
</descrip>

<sect2>Actions<label id="cbmctrl actions">
<p><it>cbmctrl</it> understands the following actions:

<descrip>
<label id="action-reset">
<tag>reset</tag>
This action performs a hardware reset of all devices attached to the IEC bus.
Control is returned after it is made sure that all devices are ready.

<label id="action-detect">
<tag>detect</tag>
This action tries to detect all devices attached to the IEC bus.
For this, this subcommand accesses all possible devices and tries to
read some bytes from its memory. If a devices is detected, its name
is output. Additionally, this routine determines if the device is
connected via a parallel cable (XP1541 companion cable for XA1541/XM1541 cables,
or the equivalent option for the XU1541 or XUM1541 cables; may be true for disk
drives only).

<label id="action-lock">
<tag>lock</tag>
This command locks the parallel port for the use by opencbm, so that
sequences of e.g. <it/talk//<it/read//<it/untalk or <it/listen//<it/write//<it/unlisten/
are not broken by concurrent processes wanting to access the parallel port.

You should issue <it/cbmctrl lock/ before doing any access to opencbm tools,
and <it/cbmctrl unlock/ after you are done.

<label id="action-unlock">
<tag>unlock</tag>
This command unlocks the parallel port after the use by opencbm.

You should issue <it/cbmctrl lock/ before doing any access to opencbm tools,
and <it/cbmctrl unlock/ after you are done.

<label id="action-listen">
<tag>listen <it/device secadr/</tag>
Tell device <it>device</it> to listen on secondary address
<it/secadr/. Until the next <it/unlisten/ command,
everything output with <it>cbmctrl write</it> will be
received by this device.<p>

This command corresponds to the following 6502 assembly code on a C64:
<code>
lda #device
jsr $ffb1
lda #secadr
ora #$60
jsr $ff93
</code>

<label id="action-talk">
<tag>talk <it/device secadr/</tag>
Tell device <it/device/ to talk on secondary address <it/secadr/. Until
the next <it/untalk/ command, data from this device can be received device by
using the command <it>cbmctrl read</it>.<p>

This command corresponds to the following 6502 assembly code on a C64:
<code>
lda #device
jsr $ffb4
lda #secadr
ora #$60
jsr $ff96
</code>

<label id="action-unlisten">
<tag>unlisten</tag>
Ends communication with listening devices after a <it/listen/ command. This
corresponds to the C64 kernel routine $ffae.

<label id="action-untalk">
<tag>untalk</tag>
Ends communication with talking devices after a <it/talk/ command. This
corresponds to the C64 kernel routine $ffab.

<label id="action-open">
<tag>open <it/device secadr filename/</tag>
Open file <it/filename/ on device <it/device/. After opening, data can be
read/written by sending a <it/talk/ resp. <it/listen/ command with the
secondary address <it/secadr/.

If <it/secadr/ is greater than 1, the file type and access mode must also be
specified by appending <tt/,type,mode/ to <it/filename/. Valid types are
D, P, S, U, R (DEL, PRG, SEQ, USR, REL), valid modes are R for reading and W
for writing.

Depending upon if <it>--petscii</it> or <it>--raw</it> is specified, the file
name is converted before being sent on the IEC bus.

Note: You cannot do an open without a filename. Although a CBM machine (i.e., a
C64) allows this, this is an internal operation for the Computer only. It does
not have any effect on the IEC bus.

<label id="popen">
<tag>popen <it/device secadr filename/</tag>
Like <it/cbmctrl open/, but converts the filename from ASCII to PetSCII before
sending it to the floppy.

Its use is deprecated, use <it/open/ with <it/--petscii/ instead.

<label id="action-close">
<tag>close <it/device secadr/</tag>
Close the file associated with secondary address <it/secadr/ on device
<it/device/.

<label id="action-read">
<tag>read <it/[file]/</tag>
This command reads raw data from the IEC bus and outputs it into the given
file, or to stdout if no file is given (or if it is a simple dash, "-").

If <it/--petscii/ is given, the output is converted from PETSCII before being
output to the file or to stdout.

<label id="action-write">
<tag>write <it/[file]/</tag>
This command writes raw data to the IEC bus; the data is taken from the given
file, or from stdin if no filename is given (or if it is a simple dash, "-").
If <it/--petscii/ is given, the output is converted to PETSCII before being
output to the IEC bus.

<label id="action-put">
<tag>put <it/[-e|--extended] &lt;datastr&gt; [&lt;data1&gt; ... &lt;dataN&gt;]/</tag>

puts the specified data to the IEC bus

With this command, you can write raw data to the IEC bus.
&lt;datastr&gt; is the string to output to the IEC bus.
          It must be given, but may be empty by specifying it as "".

&lt;data1&gt;, ..., &lt;dataN&gt; are additional bytes to append to the string &lt;datastr&gt;.
           Single bytes can be given as decimal, octal (0 prefix) or
           hexadecimal (0x prefix).

If the option <it/-e/ or <it/--extended/ is given, an extended format is used:
  You can specify extra characters by given their ASCII value in hex,
  prepended with `%', that is: `%20' => SPACE, `%41' => `A', `%35' => `5',
  and-so-on. A `%' is given by giving its hex ASCII: `%25' => `%'.

If using both <it/--pestscii/ and <it/--extended/ options, the bytes given via the
  `%' meta-character or as &lt;data1&gt;, ..., &lt;dataN&gt; are <em/not/ converted to petscii.

<label id="action-status">
<tag>status <it/device/</tag>
Copies input from device <it/device/, secondary address 15 (command/status
channel), to the standard output stream. Note that all upper case characters
are changed to lower case. Carriage return (0x0d) is also changed to the
current operating system's line ending convention (0x0a on Unix oriented
systems, 0x0d 0x0a on Windows oriented systems or whatever else is appropriate
for your operating system).

Assuming the device number is 8, this command is similar to (in this case, no
character conversions would be made)
<code>
cbmctrl lock
cbmctrl talk 8 15
cbmctrl read
cbmctrl untalk
cbmctrl unlock
</code>

The output depends upon if <it/--petscii/ or <it/--raw/ is specified.

<label id="action-command">
<tag>command <it/device cmdstr/</tag>
Sends <it/cmdstr/ to device <it/device/, secondary address 15 (command/status
channel).

Depending upon if <it>--petscii</it> or <it>--raw</it> is specified, the file
name is converted before being sent on the IEC bus. Be careful, though, because
the <it>--petscii</it> conversion might break some commands like <tt/M-W/ and
<tt/M-E/. If in doubt, it is better to use <it/--raw/ and use the commands in
<em/upper case/ (kind of poor man's PetSCII conversion).

Assuming the device number is 8, this command is identical to (Note: This does
not work on Windows, because <it/echo/ there does not know the <it/-n/ option.)
<code>
cbmctrl lock
cbmctrl listen 8 15
cbmctrl put "cmdstr"
cbmctrl unlisten
cbmctrl unlock
</code>

Note that the command <it/cbmctrl put "cmdstr"/ replaced the older variant
<it/echo -n cmdstr|cbmctrl write -/, which still works.

<label id="action-pcommand">
<tag>pcommand <it/device cmdstr/</tag>
Like <it/command/, but converts the data from ASCII to PetSCII before sending
it. Its use is deprecated, use <it/command/ with <it/--petscii/ instead.

<label id="action-dir">
<tag>dir <it/device/</tag>
Read directory from disk in device <it/device/, print on standard out.

The output depends upon if <it/--petscii/ or <it/--raw/ is specified.

<label id="action-download">
<tag>download <it/device address count [file]/</tag>
Read <it/count/ bytes from drive memory, starting at <it/address/ via one
or more <tt/M-R/ commands. Memory contents are written to standard output
if <it/file/ is <tt/"-"/ or ommited.

<label id="action-upload">
<tag>upload <it/device address [file]/</tag>
Send <it/file/ to drive memory, starting at <it/address/ via one
or more <tt/M-W/ commands. If <it/address/ is -1, the first two bytes from
<it/file/ are considered as start address. Reads standard input if <it/file/ is
<tt/"-"/ or ommited.

<label id="change">
<tag>change <it/device/</tag>
Wait for a disk to be changed in the specified device. It waits for the current
disk to be removed, for a new disk to be inserted and for the drive door to be
closed. It does not return until the disk is ready to be read or written.
</descrip>

<sect2>cbmctrl Examples<label id="cbmctrl examples">

<p>
Send file contents to printer 4:
<code>
cbmctrl lock
cbmctrl listen 4 0
cbmctrl write file
cbmctrl unlisten
cbmctrl unlock
</code>

<p>
Copy file to disk drive 8:
<code>
cbmctrl lock
cbmctrl open 8 2 FILENAME,P,W
cbmctrl listen 8 2
cbmctrl write file
cbmctrl unlisten
cbmctrl close 8 2
cbmctrl unlock
</code>

<p>
Copy file from disk drive 8:
<code>
cbmctrl lock
cbmctrl open 8 2 FILENAME,P,R
cbmctrl talk 8 2
cbmctrl read file
cbmctrl untalk
cbmctrl close 8 2
cbmctrl unlock
</code>

<p>
Dump 1541 ROM:
<code>
cbmctrl download 8 0xc000 0x4000 > 1541.rom
</code>
or
<code>
cbmctrl download 8 0xc000 0x4000 1541.rom
</code>

<p>
Write file buffer2.bin to drive 9, address 0x500:
<code/cbmctrl upload 9 0x500 buffer2.bin/

<sect1>cbmformat<label id="cbmformat">
<p>
<it/cbmformat/ is a fast low-level disk formatter for the 1541 and compatible
devices (1570, 1571, third-party clones). A 1581 drive is not supported.

The drive routine was taken from the Star Commander ((C) Joe Forster/STA) and
highly improved.

There is also another, very similar tool, <ref id="cbmforng" name="cbmforng">.

<sect2>cbmformat invocation<label id="invoking-cbmformat">
<p>
Synopsis: <tt/cbmformat [OPTION]... DRIVE# NAME,ID/

<it/DRIVE#/ has to be the drive number of the disk drive, <it/NAME/ is a name
with up to 16 characters which will be the name of the disk after formatting,
<it/ID/ is the 2-letter disk ID.

<p>Note: Unlike the <it/N0/ command of the drive, the ID must be given (thus,
no so-called "short format" is possible).

<p>
Here's a complete list of known options:

<descrip>
<tag/-h, --help/
Display help and exit.

<tag/-V, --version/
Display version information and exit.

<tag/-@, --adapter=&lt;plugin&gt;[:&lt;bus&gt;]/
<p>Specify the plugin to use. If you have installed more than one plugin
(XA1541, XU1541, XUM1541), you can specifiy which one to use for this command.
This way, you can use all three variants at the same time.

This requires an argument of the form &lt;plugin&gt;[:&lt;bus&gt;], where
&lt;plugin&gt; is the plugin's backend name (currently: <it/xa1541/,
<it/xu1541/, <it/xum1541/), and &lt;bus&gt; is the bus identifier, if it is
supported by the backend.

<tag/-n, --no-bump/
Do not bump drive head at the beginning. Don't use this on eventually
misaligned drives.

<tag/-x, --extended/
Format a 40 track disk, the BAM format is compatible to SpeedDOS.

<tag/-c, --clear/
clear (demagnetize) this disk.
This is highly recommended if the disk is used for the first time,
or if it was previously formatted for another system (i.e., MS-DOS).
Note that this option takes much time.

<tag/-v, --verify/
verify each track after it is written.
As this needs an extra round of the drive for each track, the formatting time
is almost doubled.

cf. <ref id="note-1571-cbmformat" name="cbmformat Notes for 1571 drives">

<tag/-o, --original/
Fill sectors with the original pattern (0x4b, 0x01, 0x01...) instead of zeroes.
The original pattern is probably due to a bug in the drive ROM, apart from
this, zeroing out unused sectors should give (slightly) better results for
compressed disk images.

cf. <ref id="note-1571-cbmformat" name="cbmformat Notes for 1571 drives">

<tag/-s, --status/
Display drive status after formatting. Normally, <it/cbmformat/ exits after
executing the drive code. With this option turned on, <it/cbmformat/ waits
until the drive has finished formatting and prints the drive status after
initializing the BAM on standard out.

<tag/-p, --progress/
Display a hash mark ('#') for each formatted track. Slows formatting down a 
bit.
</descrip>

<sect2>cbmformat Notes for 1571 drives<label id="note-1571-cbmformat">
<p>
We encountered problems with decent revision/mechanics combinations of the
1571 disk drives when using cbmformat. We highly recommend to use
<it/--original/ and <it/--verify/ with 1571 drives. From our experience, with
<it/--original/, the problem does not occur; with <it/--verify/, the drive
tests each track after it was formatted and ensures that the failure condition
did not occur.

We did not encounter these problems with either of 1541 (1541-II, 1541C), 1570
or 1571CR (the drive which is part of the C128DCR) drives, only with original
1571 drives.

In the current state, cbmformat is not able to format double-sided disks on a
1571 drive.

<sect2>cbmformat Examples<label id="cbmformat examples">

<p>
Format standard disk (35 tracks) in drive 8:
<code>
cbmformat 8 GAMES,42
</code>

<p>
Format standard disk (35 tracks) in drive 9, use (buggy) 1541 sector pattern (for example, because this is a 1571 drive), show drive status when done:
<code>
cbmformat -os 9 1571disk,71
</code>

<p>
SpeedDOS disk (40 tracks), show progress indicator, all sectors zeroed out,
no head banging:
<code>
cbmformat -npx 8 "40 TRACKS,OK"
</code>

<sect1>cbmforng<label id="cbmforng">
<p>
<it>cbmforng</it> is a fast and reliable low-level disk formatter for the
1541 and compatible devices (1570, 1571, third-party clones). It was based
on <ref id="cbmformat" name="cbmformat"> and is designed to become the
designated successor to <ref id="cbmformat" name="cbmformat">, therefore its
name: <it>CBM-Formatter, the Next Generation</it>.

<it/cbmforng/ does not support a 1581 drive.

<p>
Because this is the first official release of <it>cbmforng</it> and because
it was not used in the field by a wider user group, it still contains
additional measurement routines and informational output after the formatting
process was done. When <it>cbmforng</it> prooved its matureness and got back
some features currently missing (progress bar), it will replace
<it>cbmformat</it>.
<p>
To date <it/cbmforng/ should be considered as the more reliable formatter of
both; whenever you should encounter any difficulties with <it>cbmformat</it>,
go for <it/cbmforng/. If you like additional informational messages like e.g.
the RPM value each formatted track was measured, then <it/cbmforng/ is the tool
you want to use. Your feedback helps us to decide, if this additional output
which was needed for developing may find its way into future releases.

<sect2>cbmforng invocation<label id="invoking-cbmforng">
<p>
Synopsis: <tt/cbmforng [OPTION]... DRIVE# NAME,ID/

<it/DRIVE#/ has to be the drive number of the disk drive, <it/NAME/ is a name
with up to 16 characters which will be the name of the disk after formatting,
<it/ID/ is the 2-letter disk ID.

<p>Note: Unlike the <it/N0/ command of the drive, the ID must be given (thus,
no so-called "short format" is possible).

<p>
Here's a complete list of known options:

<descrip>
<tag/-h, --help/
Display help and exit.

<tag/-V, --version/
Display version information and exit.

<tag/-@, --adapter=&lt;plugin&gt;[:&lt;bus&gt;]/
<p>Specify the plugin to use. If you have installed more than one plugin
(XA1541, XU1541, XUM1541), you can specifiy which one to use for this command.
This way, you can use all three variants at the same time.

This requires an argument of the form &lt;plugin&gt;[:&lt;bus&gt;], where
&lt;plugin&gt; is the plugin's backend name (currently: <it/xa1541/,
<it/xu1541/, <it/xum1541/), and &lt;bus&gt; is the bus identifier, if it is
supported by the backend.

<tag/-n, --no-bump/
Do not bump drive head at the beginning. Don't use this on eventually
misaligned drives.

<tag/-r, --retries n/
Set the maximum number of retries on errors. This accounts for all
errors that may happen when formatting all the tracks of the whole disk.

<tag/-x, --extended/
Format a 40 track disk, the BAM format is compatible to SpeedDOS.

<tag/-c, --clear/
clear (demagnetize) this disk.
This is highly recommended if the disk is used for the first time,
or if it was previously formatted for another system (i.e., MS-DOS).
Note that this option takes much time.

<tag/-v, --verify/
verify each track after it is written.
As this needs an extra round of the drive for each track, the formatting time
is almost doubled.

cf. <ref id="note-1571-cbmforng" name="cbmforng Notes for 1571 drives">

<tag/-o, --original/
Fill sectors with the original pattern (0x4b, 0x01, 0x01...) instead of zeroes.
The original pattern is probably due to a bug in the drive ROM, apart from
this, zeroing out unused sectors should give (slightly) better results for
compressed disk images. In comparison to <it>cbmformat</it>, the pattern used
with <it>cbmforng</it> is a little bit more original than the one from its
predecessor. On track one the pattern consists of: 0x00, 0x01, 0x01, ...
instead of the first byte beeing 0x4b. This perfectly reflects the original
1541 ROM format bug.

cf. <ref id="note-1571-cbmforng" name="cbmforng Notes for 1571 drives">

<tag/-s, --status/
In addition to the informational output of internal values from the formatting
process, the drive status is displayed.
<!--
Womo: As long as the additional informational output is given after
      formatting, cbmforng does not exit in either case. Therefore
      the following note does not apply yet.

Display drive status after formatting. Normally, <it/cbmforng/ exits
after executing the drive code. With this option turned on, <it/cbmforng/
waits until the drive has finished formatting and prints the drive status
after initializing the BAM on standard out.
-->
</descrip>

<sect2>cbmforng Notes for 1571 drives<label id="note-1571-cbmforng">
<p>
We encountered rare failure conditions with decent revision/mechanics
combinations of the 1571 disk drives when using cbmforng. We highly
recommend to use <it/--original/ and <it/--verify/ with 1571 drives. From
our experience, with <it/--original/, the problem does not occur. With
<it/--verify/, the drive tests each track after it was formatted and ensures
that the failure condition did not occur; otherwise the same track is formatted
again, as often as the currently set retry value allows.

We did not encounter these problems with either of 1541 (1541-II, 1541C), 1570
or 1571CR (the drive which is part of the C128DCR) drives, only with original
1571 drives.

In the current state, cbmforng is not able to format double-sided disks on a
1571 drive.

<sect2>cbmforng Examples<label id="cbmforng examples">

<p>
Format standard disk (35 tracks) in drive 8:
<code>
cbmforng 8 GAMES,42
</code>

<p>
Format standard disk (35 tracks) in drive 9, use (buggy) 1541 sector pattern
(for example, because this is a 1571 drive), show drive status when done:
<code>
cbmforng -os 9 1571disk,71
</code>

<p>
SpeedDOS disk (40 tracks), verify formatted tracks, all sectors zeroed out,
no head banging:
<code>
cbmforng -nvx 8 "40 TRACKS,OK"
</code>


<sect1>d64copy<label id="d64copy">
<p>
<it/d64copy/ is a fast disk image transfer (both read and write) program for
the 1541 and compatible devices (1570, 1571, third-party clones). A 1581 drive
is <it/not/ supported! Maximum transfer speed is achieved by custom drive- and
transfer-routines based on the Star Commander ((C) Joe Forster/STA) routines.

See also <ref id="d82copy" name="d82copy"> and <ref id="imgcopy"
name="imgcopy">.

<sect2>d64copy invocation<label id="invoking-d64copy">
<p>
Synopsis: <tt/d64copy [OPTION]... SOURCE TARGET/

<p>
Either SOURCE or TARGET must be an external drive, valid names are 8, 9, 10 and
11. The other parameter specifies the file name of the .d64 image.

Here's a complete list of known options:

<descrip>
<tag/-h, --help/
Display help and exit

<tag/-V, --version/
Display version information and exit.

<tag/-@, --adapter=&lt;plugin&gt;[:&lt;bus&gt;]/
<p>Specify the plugin to use. If you have installed more than one plugin
(XA1541, XU1541, XUM1541), you can specifiy which one to use for this command.
This way, you can use all three variants at the same time.

This requires an argument of the form &lt;plugin&gt;[:&lt;bus&gt;], where
&lt;plugin&gt; is the plugin's backend name (currently: <it/xa1541/,
<it/xu1541/, <it/xum1541/), and &lt;bus&gt; is the bus identifier, if it is
supported by the backend.

<tag/-q, --quiet/
Quiet output, fewer messages (also suppresses warnings, should not be used)

<tag/-v, --verbose/
Verbose output, more messages (can be repeated)

<tag/-n, --no-progress/
Omit progress display

<tag>-s, --start-track=<it/start track/</tag>
Set start track (defaults to 1)

<tag>-e, --end-track=<IT/End track/</tag>
Set end track (default is 35 for .d64 images, 70 for .d71 images). <it/d64copy/
is able to access tracks 1-35 in <tt/original/ transfer mode and 1-42 with
<tt/serial1/, <tt/serial2/ and <tt/parallel/. The 1571 supports tracks 1-70
in double sided (.d71) mode.

<tag>-t, --transfer=<it/transfer mode/</tag>
Set transfermode. Valid modes are:
<itemize>
<item><tt/auto/     (default)
<item><tt/original/ (slowest)
<item><tt/serial1/
<item><tt/serial2/
<item><tt/parallel/ (fastest)
</itemize>
<tt/original/ and <tt/serial1/ should work in any case.
<tt/serial2/ won't work with more than one device
connected to the IEC bus, 
<tt/parallel/ requires an additional XP1541/XP1571 cable.

<p>
If <tt/auto/ is used, d64copy itself determines the best transfer mode usable
with the current setup, and uses that one. Thus, you will seldom want to 
manually overdrive the <it>transfer mode</it> option.

<tag>-i, --interleave=<it/interleave/</tag>
Set interleave value. This is ignored when reading in warp mode. Default is 16
for transfer mode <tt/original/, for turbo and warp write as follows:
<tscreen><verb>

          turbo (r/w)    warp (write only)
serial1       3                 5
serial2      12                11
parallel      6                 3

</verb></tscreen>
Lower values might slightly reduce transfer times, but if set a bit to low,
transfer times will dramatically increase.

<tag>-w, --warp</tag>
Enable warp mode. This is default now; this option is only supported for
backward-compatibility with opencbm (cbm4linux/cbm4win) versions before 0.4.0.

<tag>--no-warp</tag>
Disable warp mode. Warp mode is usually a good idea for transferring disk
images unless you have a very slow CPU and/or bad disk material. Warp mode
sends raw GCR data over the bus, which assures data integrity on the PC side
and relieves the drive's CPU. Thus, it is unlikely you will want to use that
option.

<tag>-b, --bam-only</tag>
BAM-only copy. Only blocks marked as allocated are copied. For extended tracks
(36-40), SpeedDOS BAM format is assumed. Use with caution, at least one wide-spread
directory editor tends to forget to allocate some directory blocks.

<tag>-B, --bam-save</tag>
Safe BAM-only copy. This is like the <tt/-b/ option but always copies the
entire directory track (18, 18 and 53 in double-sided mode).

<tag>-d, --drive-type=<tt/type/</tag>
Skip drive type detection. <tt/0/ or <tt/1541/ specifies 1541 mode (1 MHz,
parallel cable at VIA $1800), <tt/1/ or <tt/1571/ forces 1571 mode (2 MHz,
parallel cable at CIA $4000).

<tag>-2, --two-sided</tag>
Double-sided mode for copying .d71 images to/from a 1571 drive. Warp mode is
not supported (yet).

<tag>-r, --retry-count=<tt/count/</tag>
Number of retries.

<tag>-E, --error-map=<tt/mode/</tag>
Controls whether error is appended to the disk image (15x1->PC only).
Allowed values for <tt/mode/ are (abbreviations allowed):
<itemize>
<item><tt/always/
<item><tt/on_error/  (default)
<item><tt/never/
</itemize>

</descrip>

<sect2>d64copy Examples<label id="d64copy examples">

<p>
Read a D64 disk image from the floppy in drive 8 to the file image.d64,
automatically selecting the fastest transfer method:
<code>
d64copy 8 image.d64
</code>

<p>
Copy the D64 disk image in image.d64 to the floppy in drive 9, automatically
selecting the fastest transfer method:
<code>
d64copy image.d64 9
</code>

<p>
Copy a double-sided disk from a 1571 drive 9 to image.d71, using
<tt/serial1/ transfer method and only reading the blocks which are
marked as used in the BAM:
<code>
d64copy -2 -B --transfer=serial1 9 image.d64
</code>

<sect1>d82copy<label id="d82copy">

<p>
<it/d82copy/ is a fast disk image transfer (both read and write) program for
the 8050, 8250 and SFD 1001. 

<p>
See also <ref id="d64copy" name="d64copy"> and <ref id="imgcopy"
name="imgcopy">.

<sect2>d82copy invocation<label id="invoking-d82copy">
<p>
Synopsis: <tt/d82copy [OPTION]... SOURCE TARGET/

<p>
Either SOURCE or TARGET must be an external drive, valid names are 8, 9, 10 and
11. The other parameter specifies the file name of the .d80 or .d82 image.

Here's a complete list of known options:

<descrip>
<tag/-h, --help/
Display help and exit

<tag/-V, --version/
Display version information and exit.

<tag/-@, --adapter=&lt;plugin&gt;[:&lt;bus&gt;]/
<p>Specify the plugin to use. If you have installed more than one plugin
(XA1541, XU1541, XUM1541), you can specifiy which one to use for this command.
This way, you can use all three variants at the same time.

This requires an argument of the form &lt;plugin&gt;[:&lt;bus&gt;], where
&lt;plugin&gt; is the plugin's backend name (currently: <it/xa1541/,
<it/xu1541/, <it/xum1541/), and &lt;bus&gt; is the bus identifier, if it is
supported by the backend.

<tag/-q, --quiet/
Quiet output, fewer messages (also suppresses warnings, should not be used)

<tag/-v, --verbose/
Verbose output, more messages (can be repeated)

<tag/-n, --no-progress/
Omit progress display

<tag>-s, --start-track=<it/start track/</tag>
Set start track (defaults to 1)

<tag>-e, --end-track=<IT/End track/</tag>
Set end track (default is 77 for .d80 images, 154 for .d82 images).

<tag>-t, --transfer=<it/transfer mode/</tag>
Set transfermode. Valid modes are:
<itemize>
<item><tt/auto/     (default)
<item><tt/original/ (slowest)
</itemize>

<p>
If <tt/auto/ is used, d82copy itself determines the best transfer mode usable
with the current setup, and uses that one. Thus, you will seldom want to 
manually overdrive the <it>transfer mode</it> option.

<p>
Note that <it/d82copy/ currently only supports <it/original/ mode; thus, either
<it/auto/ or omitting the transfer mode will both default to <it/original/.

<tag>-i, --interleave=<it/interleave/</tag>
Set interleave value. This is ignored when reading in warp mode. Default is 16
for transfer mode <tt/original/, for turbo and warp write as follows:
<tscreen><verb>

original     22

</verb></tscreen>
Lower values might slightly reduce transfer times, but if set a bit to low,
transfer times will dramatically increase.

<tag>-w, --warp</tag>
Enable warp mode. This is default now; this option is only supported for
backward-compatibility with opencbm (cbm4linux/cbm4win) versions before 0.4.0.

<p>
Note that <it/d82copy/ currently supports <it/original/ transfer mode only;
thus, <it/--warp/ and <it/--no-warp/ are ignored at the moment.

<tag>--no-warp</tag>
Disable warp mode. Warp mode is usually a good idea for transferring disk
images unless you have a very slow CPU and/or bad disk material. Warp mode
sends raw GCR data over the bus, which assures data integrity on the PC side
and relieves the drive's CPU. Thus, it is unlikely you will want to use that
option.

<p>
Note that <it/d82copy/ currently supports <it/original/ transfer mode only;
thus, <it/--warp/ and <it/--no-warp/ are ignored at the moment.

<tag>-b, --bam-only</tag>
BAM-only copy. Only blocks marked as allocated are copied.

<tag>-B, --bam-save</tag>
Safe BAM-only copy. This is like the <tt/-b/ option but always copies the
entire directory track (18, 18 and 53 in double-sided mode).

<tag>-d, --drive-type=<tt/type/</tag>
Skip drive type detection. Possible values are: <tt/8050/, <tt/8250/ or
<tt/1001/.

<tag>-1, --one-sided</tag>
Single-sided mode (D80).

<tag>-2, --two-sided</tag>
Double-sided mode (D82); requires a VIC 8250 or SFD 1001 drive.

<tag>-r, --retry-count=<tt/count/</tag>
Number of retries.

<tag>-E, --error-map=<tt/mode/</tag>
Controls whether error is appended to the disk image (15x1->PC only).
Allowed values for <tt/mode/ are (abbreviations allowed):
<itemize>
<item><tt/always/
<item><tt/on_error/  (default)
<item><tt/never/
</itemize>

</descrip>

<sect2>d82copy Examples<label id="d82copy examples">

<p>
Read a D82 disk image from the floppy in drive 8 to the file image.d82,
automatically selecting the fastest transfer method:
<code>
d82copy -2 8 image.d82
</code>

<p>
Copy the D80 disk image in image.d80 to the floppy in drive 9, automatically
selecting the fastest transfer method:
<code>
d82copy -1 image.d80 9
</code>

<p>
Copy a double-sided disk from a 1001 drive 9 to image.d82, only reading the
blocks which are marked as used in the BAM:
<code>
d82copy -2 -B --drive-type=1001 9 image.d82
</code>


<sect1>imgcopy<label id="imgcopy">

<p>
<it/imgcopy/ is a fast disk image transfer (both read and write) program for
various CBM disk drives, namely, VIC 1540, 1541, 1570, 1571, 1581, 2031, 2040,
3040, 4031, 4040, 8050, 8250, and SFD 1001.

<p>
See also <ref id="d64copy" name="d64copy"> and <ref id="d82copy"
name="d82copy">.


<sect2>imgcopy invocation<label id="invoking-imgcopy">
<p>
Synopsis: <tt/imgcopy [OPTION]... SOURCE TARGET/

<p>
Either SOURCE or TARGET must be an external drive, valid names are 8, 9, 10 and
11. The other parameter specifies the file name of the image file.

The extension of the image file determines the default Imagefiletype (.d64,
.d71, .d80, .d81, .d82)
<itemize>
<item><tt/.d64/  1540, 1541, 1570, 1571 (single-sided) or 2031 image
<item><tt/.d71/  1571 image (double-sided)
<item><tt/.d81/  1581 image
<item><tt/.d80/  8050 image (single-sided)
<item><tt/.d82/  8250 or 1001 image (double-sided)
</itemize>

Here's a complete list of known options:

<descrip>
<tag/-h, --help/
Display help and exit

<tag/-V, --version/
Display version information and exit.

<tag/-@, --adapter=&lt;plugin&gt;[:&lt;bus&gt;]/
<p>Specify the plugin to use. If you have installed more than one plugin
(XA1541, XU1541, XUM1541), you can specifiy which one to use for this command.
This way, you can use all three variants at the same time.

This requires an argument of the form &lt;plugin&gt;[:&lt;bus&gt;], where
&lt;plugin&gt; is the plugin's backend name (currently: <it/xa1541/,
<it/xu1541/, <it/xum1541/), and &lt;bus&gt; is the bus identifier, if it is
supported by the backend.

<tag/-q, --quiet/
Quiet output, fewer messages (also suppresses warnings, should not be used)

<tag/-v, --verbose/
Verbose output, more messages (can be repeated)

<tag/-n, --no-progress/
Omit progress display

<tag>-s, --start-track=<it/start track/</tag>
Set start track (defaults to 1)

<tag>-e, --end-track=<IT/End track/</tag>
Set end track (default depends upon the file image type).

<tag>-t, --transfer=<it/transfer mode/</tag>
Set transfermode. Valid modes are:
<itemize>
<item><tt/auto/     (default)
<item><tt/original/ (slowest)
<item><tt/serial1/
<item><tt/serial2/
<item><tt/serial3/
<item><tt/parallel/ (fastest)
</itemize>

<p>
Not all modes are supported with all drives!

<p>
If <tt/auto/ is used, imgcopy itself determines the best transfer mode usable
with the current setup, and uses that one. Thus, you will seldom want to 
manually overdrive the <it>transfer mode</it> option.

<tag>-i, --interleave=<it/interleave/</tag>
Set interleave value. This is ignored when reading in warp mode.
The default depends upon the file image type.

Lower values might slightly reduce transfer times, but if set a bit to low,
transfer times will dramatically increase.

<tag>-w, --warp</tag>
Enable warp mode. This is default now; this option is only supported for
backward-compatibility with opencbm (cbm4linux/cbm4win) versions before 0.4.0.

<tag>--no-warp</tag>
Disable warp mode. Warp mode is usually a good idea for transferring disk
images unless you have a very slow CPU and/or bad disk material. Warp mode
sends raw GCR data over the bus, which assures data integrity on the PC side
and relieves the drive's CPU. Thus, it is unlikely you will want to use that
option.

<tag>-b, --bam-only</tag>
BAM-only copy. Only blocks marked as allocated are copied.

<tag>-B, --bam-save</tag>
Safe BAM-only copy. This is like the <tt/-b/ option but always copies the
entire directory track (18, 18 and 53 in double-sided mode).

<tag>-d, --drive-type=<tt/type/</tag>
Skip drive type detection. Possible values are: <tt/1541/, <tt/1571/, <tt/1581/,
<tt/2031/, <tt/2040/, <tt/3040/,  <tt/4031/, <tt/4040/, <tt/8050/, <tt/8250/ or
<tt/1001/.

<tag>-1, --one-sided</tag>
Single-sided mode (D80).

<tag>-2, --two-sided</tag>
Double-sided mode (D82); requires a VIC 8250 or SFD 1001 drive.

<tag>-r, --retry-count=<tt/count/</tag>
Number of retries.

<tag>-E, --error-map=<tt/mode/</tag>
Controls whether error is appended to the disk image (15x1->PC only).
Allowed values for <tt/mode/ are (abbreviations allowed):
<itemize>
<item><tt/always/
<item><tt/on_error/  (default)
<item><tt/never/
</itemize>

</descrip>

<sect2>imgcopy Examples<label id="imgcopy examples">


<sect1>cbmcopy<label id="cbmcopy">
<p>
<it/cbmcopy/ is a fast file transfer program for various disk drives,
in particular the 1541, 1570, 1571 and 1581 devices.
Maximum transfer speed is achieved by custom drive- and transfer-routines based
on the Star Commander ((C) Joe Forster/STA) routines.

<sect2>cbmcopy invocation<label id="invoking-cbmcopy">
<p>
Synopsis: <tt/cbmcopy [OPTION]... DEVICE# FILE.../

<p>
DEVICE# specifies the drive number for file copy.
The remaining arguments specify the files to be sent to/read from the disk
drive. This version supports 
Raw, PC64 (P00) and T64 files. They are recognized when sending files to the
disk drive, files read from external devices are always stored as raw binary
data.

Here's a complete list of known options:

<descrip>
<tag/-h, --help/
Display help and exit

<tag/-V, --version/
Display version information and exit.

<tag/-@, --adapter=&lt;plugin&gt;[:&lt;bus&gt;]/
<p>Specify the plugin to use. If you have installed more than one plugin
(XA1541, XU1541, XUM1541), you can specifiy which one to use for this command.
This way, you can use all three variants at the same time.

This requires an argument of the form &lt;plugin&gt;[:&lt;bus&gt;], where
&lt;plugin&gt; is the plugin's backend name (currently: <it/xa1541/,
<it/xu1541/, <it/xum1541/), and &lt;bus&gt; is the bus identifier, if it is
supported by the backend.

<tag/-q, --quiet/
Quiet output, fewer messages (also suppresses warnings, should not be used)

<tag/-v, --verbose/
Verbose output, more messages (can be repeated)

<tag/-n, --no-progress/
Omit progress display

<tag/-r, --read/
Operate in read-mode, i.e. read data from an external device.
Starting <it/cbmcopy/ as <it/cbmread/ has the same effect.

<tag/-w, --write/
Operate in write-mode, i.e. send files to an external device.
Starting <it/cbmcopy/ as <it/cbmwrite/ has the same effect.

<tag>-t, --transfer=<it/transfer mode/</tag>
Set transfermode. Valid modes are:
<itemize>
<item><tt/auto/    (default)
<item><tt/serial1/  (slowest)
<item><tt/serial2/
<item><tt/parallel/ (fastest, not possible with a 1581)
</itemize>
<tt/serial1/ should work in any case.
<tt/serial2/ won't work with more than one device
connected to the IEC bus, 
<tt/parallel/ requires a XP1541/XP1571 cable in addition to the XM/XA1541.
If <tt/auto/ is given, or this option is completely omitted, cbmcopy
will automatically determine the fastest transfer method possible with the
current setup. Thus, you will seldom want to  manually overdrive the
<it>transfer mode</it> option.

<tag>-d, --drive-type=<tt/type/</tag>
Skip drive type detection.
Valid types are <tt/1541/, <tt/1570/, <tt/1571/ and <tt/1581/.

<tag>-o, --output=<tt/name/</tag>
Specifies target name. ASCII/PetSCII conversion is performed when in write-mode.

<tag>-a, --address=<tt/address/</tag>
Overrides the file's first two bytes with <it/address/.

<tag/-R, --raw/
Skip file type detection. File data is sent as is.
This option is only valid in write-mode.

<tag>-f, --file-type=<tt/type/</tag>
Specifies/overrides file type. Supported types are <tt/P/, <tt/S/, <tt/D/,
<tt/U/.
Raw files default to <tt/P/, whereas the T64 format contains meta data
which includes the file type. For PC64 files, <it/cbmwrite/ tries to guess
the file type from the file extension.
This option is only valid in write-mode.

</descrip>

<sect2>cbmcopy Examples<label id="cbmcopy examples">

<p>
Read a file called <it/cbmfile/ from drive 8 and store its binary value into
the file file.bin, automatically selecting the fastest transfer method:
<code>
cbmcopy -r 8 cbmfile -o file.bin
</code>

<p>
Write out the file file.p00 in P64 format to the disk in drive 9, using
<tt/serial1/ transfer method:
<code>
cbmcopy -w 9 file.p00
</code>

<sect1>rpm1541<label id="rpm1541">
<p>
<it/rpm1541/ is a demo program. It finds out the rotation speed (in rounds per
minute, rpm) of the drive motor.
<it/rpm1541/ supports a 1541, 1570 or 1571 drive.
A 1581 drive is <it/not/ supported.

For Linux, <it/rpm1541/ is not installed automatically. You have to compile it
yourself (found in <tt>demo/rpm1541/</tt>) if you want to use it.
For Windows, it is part of the binary distribution.

This demo program does not allow you to specify a specific adapter/plugin.
Instead, it always uses the default plugin.

<sect2>rpm1541 usage<label id="rpm1541-usage">
<p>
Synopsis: <tt>rpm1541 <it>[device]</it></tt>
<p>
The optional parameter <it>device</it> is the device number of the drive which
should be tested. If not specified, <tt/rpm1541/ utilizes drive 8.

<sect2>rpm1541 Example<label id="rpm1541-example">
<p>

Find out the rotation speed of drive 11:
<code>
cbmctrl lock
rpm1541 11
cbmctrl unlock
</code>

<sect1>flash<label id="flash">
<p>
<it/flash/ is a demo program. It flashes the drive LED.
<it/flash/ works with 1541, 1570 or 1571 drives. A 1581 drive is <it/not/ supported.

For Linux, <it/flash/ is not installed automatically. You have to
compile it yourself (found in <tt>demo/flash/</tt>) if you want to use it.
For Windows, it is part of the binary distribution.

This demo program does not allow you to specify a specific adapter/plugin.
Instead, it always uses the default plugin.

<sect2>flash usage<label id="flash-usage">
<p>
Synopsis: <tt>flash <it>[device]</it></tt>
<p>
The optional parameter <it>device</it> is the device number of the drive which
should flash its LED. If not specified, <tt/flash/ utilizes drive 8.

<sect2>flash Example<label id="flash-example">
<p>

Let the drive LED flash on drive 10:
<code>
cbmctrl lock
flash 10
cbmctrl unlock
</code>

<sect1>morse<label id="morse">
<p>
<it/morse/ is a demo program. It uses the drive LED to output a text in morse code.
<it/morse/ works with 1541, 1570 or 1571 drives. A 1581 drive is <it/not/ supported.

For Linux, <it/morse/ is not installed automatically. You have to compile it
yourself (found in <tt>demo/morse/</tt>) if you want to use it.
For Windows, it is part of the binary distribution.

This demo program does not allow you to specify a specific adapter/plugin.
Instead, it always uses the default plugin.

<sect2>morse usage<label id="morse-usage">
<p>
Synopsis: <tt>morse <it>[device]</it></tt>
<p>
The optional parameter <it>device</it> is the device number of the drive which
should flash its LED. If not specified, <tt/morse/ utilizes drive 8.

<sect2>morse Examples<label id="morse-examples">
<p>

Morse the text "SOS", "HELLO" and "YOU" (in this order) on drive 9.
<code>
cbmctrl lock
morse 9
cbmctrl command 9 U3:HELLO
cbmctrl command 9 U3:YOU
cbmctrl unlock
</code>

<sect1>cbmlinetester<label id="cbmlinetester">

<p>
This tool can be used for debugging purposes. You can use it to test and check
if the IEC lines react on actions of the PC.

<sect2>cbmlinetester invocation<label id="invoking-cbmlinetester">
<p>
Synopsis: <tt/cbmlinetester [OPTION]/

Set the IEC lines to specific values

<p>
Here's a complete list of known options:

<descrip>
<tag/-h, --help/                 display help and exit
<tag/-V, --version/              <p>display version information and exit
<tag/-@, --adapter=&lt;plugin&gt;[:&lt;bus&gt;]/
<p>Specify the plugin to use. If you have installed more than one plugin
(XA1541, XU1541, XUM1541), you can specifiy which one to use for this command.
This way, you can use all three variants at the same time.

This requires an argument of the form &lt;plugin&gt;[:&lt;bus&gt;], where
&lt;plugin&gt; is the plugin's backend name (currently: <it/xa1541/,
<it/xu1541/, <it/xum1541/), and &lt;bus&gt; is the bus identifier, if it is
supported by the backend.

<tag/-i, --interactive/          Use the tool interactively (only with ncurses)
<tag/-p, --poll/                 Poll the values of the lines

<tag/-r, --reset/                <em/set/ the RESET line (set to 0V)
<tag/-R, --RESET/                <em/release/ the RESET line (set to 5V)
<tag/-a, --atn/                  <em/set/ the ATN line (set to 0V)
<tag/-A, --ATN/                  <em/release/ the ATN line (set to 5V)
<tag/-c, --clock/                <em/set/ the CLOCK line (set to 0V)
<tag/-C, --CLOCK/                <em/release/ the CLOCK line (set to 5V)
<tag/-d, --data/                 <em/set/ the DATA line (set to 0V)
<tag/-D, --DATA/                 <em/release/ the DATA line (set to 5V)
</descrip>

<sect1>tape routines<label id="tape">

<p>
For Windows, special tape routines are avaiblel for use with the ZoomFloppy
cable. Currently, the only documentation for this can be found in the source
tarball at <it>opencbm/tape/</it>.


<sect>opencbm API<label id="opencbm-API">
<p>
The OpenCBM API is documented as doxygen file. You can find it only on
<htmlurl url="http://opencbm.trikaliotis.net/doxygen/" name="http://opencbm.trikaliotis.net/doxygen/">

<!--
<p>
All communication between the user space applications and the kernel module
is done with ioctl's. Since ioctl's are quite unportable and hardly provide
any type-safety, there are a number of wrapper-functions along with a couple
of convenience functions implemented in <tt/libopencbm.a/ (Linux) or
<tt/opencbm.dll/ (Windows). The prototypes can be found in the header file
<tt/opencbm.h/.

<sect1>Preprocessor macros<label id="opencbm-preproc">
<p>

<itemize>
<item>#define IEC_DATA 0x01</item>
<item>#define IEC_CLOCK 0x02</item>
<item>#define IEC_ATN 0x04</item>
</itemize>

These defines are used by the <it/cbm_iec_*()/ functions. You will definitely
need this if you intend to implement your own custom transfer routines. See
the <tt/libd64copy//<tt/libcbmcopy/ source for more information.

<sect1>Enumeration types<label id="opencbm-enum-types">
<p>

<itemize>
<item>enum cbm_device_type_e
<itemize>
<item/cbm_dt_unknown/
<item/cbm_dt_1541/
<item/cbm_dt_1570/
<item/cbm_dt_1571/
<item/cbm_dt_1581/
</itemize>
</itemize>

<p>
<itemize>
<item>enum cbm_cable_type_e
<itemize>
<item/cbm_ct_unknown/
<item/cbm_ct_none/
<item/cbm_ct_xp1541/
</itemize>
</itemize>

<sect1>Generic types<label id="opencbm-types">

<p>
<itemize>
<item>CBM_FILE</item>
</itemize>

This type is used to take a handle to the CBM driver. Only use this type, as it
hides the differences between Windows and Linux.

An invalid CBM_FILE has value CBM_FILE_INVALID.

<sect1>Functions<label id="opencbm-functions">
<p>

(All functions except <tt/cbm_driver_open():/ <it/f/ must be a valid file
descriptor)

<sect2>Basic I/O<label id="opencbm-basic-functions">

<p><descrip>
<tag/int cbm_driver_open(CBM_FILE *f, int port);/
Opens the driver. <tt/port/ isn't used by now and should be 0.
After successful completion, 0 is returned along with a valid CBM_FILE
descriptor in <tt/f/.

<tag/void cbm_driver_close(CBM_FILE f);/
Closes the driver.

<tag/void cbm_lock(CBM_FILE f);/
The equivalent to <it/cbmctrl lock/. Make sure the parallel port is
kept locked even if the driver is closed with cbm_driver_close().

<tag/void cbm_unlock(CBM_FILE f);/
The equivalent to <it/cbmctrl unlock/. Unlock the parallel port as soon is the
driver is closed with cbm_driver_close().

<tag/int cbm_raw_read(CBM_FILE f, void *buf, size_t size);/
Retrieve data after <tt/cbm_talk();/. At most <tt/size/ bytes are read.
Return value is the actual number of bytes read. &lt; indicates an error.

<tag/int cbm_raw_write(CBM_FILE f, const void *buf, size_t size);/
Send data after <tt/cbm_listen();/. At most <tt/size/ bytes are written,
Return value is the actual number of bytes written. &lt; indicates an error.

<tag/int cbm_listen(CBM_FILE f, unsigned char dev, unsigned char secadr);/
Tell device <it/dev/ to listen on secondary channel <it/secadr/.
Return value is 0 on success, &lt; 0 means error.

<tag/int cbm_talk(CBM_FILE f, unsigned char dev, unsigned char secadr);/
Tell device <it/dev/ to talk on secondary channel <it/secadr/.
Return value is 0 on success, &lt; 0 means error.

<tag/int cbm_open(CBM_FILE f, unsigned char dev, unsigned char secadr);/
Prepare device <it/dev/ for opening a file. This device listens for the file
name after this call which is normally sent by a call to the
<it/write()/-function followed by an <it/unlisten()/ call.
Return value 0 on success, &lt; 0 means error.

<tag/int cbm_close(CBM_FILE f, unsigned char dev, unsigned char secadr);/
Close file associated with secondary address <it/secadr/ on device <it/dev/.
Return value 0 on success, &lt; 0 means error.

<tag/int cbm_unlisten(CBM_FILE f);/
Send unlisten on bus.
Return value 0 on success, &lt; 0 means error.

<tag/int cbm_untalk(CBM_FILE f);/
Send untalk on bus.
Return value 0 on success, &lt; 0 means error.

<tag/int cbm_get_eoi(CBM_FILE f);/
Get EOI flag after bus read, return value is 0 with no EOI, otherwise 1.
When EOI is set to 1, the active talker has nothing more to send.

<tag/int cbm_clear_eoi(CBM_FILE f);/
Reset EOI flag.
Return value 0 on success, &lt; 0 means error.

<tag/int cbm_reset(CBM_FILE f);/
Do a hardware reset on all connected devices. Control is returned after
a 5 second delay.
</descrip>

<sect2>Low-level port access<label id="opencbm-lowlevel-functions">

<p><descrip>
<tag/unsigned char cbm_pp_read(CBM_FILE f);/
Read byte from XP1541/XP1571 bus. No handshaking or such involved.

<tag/void cbm_pp_write(CBM_FILE f, unsigned char c);/
Write byte to XP1541/XP1571 bus. No handshaking or such involved.

<tag/int cbm_iec_poll(CBM_FILE f);/
Read status of all bus lines. Return value is a combination of 
<tt/IEC_ATN/, <tt/IEC_CLOCK/ and <tt/IEC_DATA/.

<tag/int cbm_iec_get(CBM_FILE f, int line);/
Get (logical) status of line <it/line/.

<tag/void cbm_iec_set(CBM_FILE f, int line);/
Activate lines <it/line/ (set to 0V).
<it/line/ can be one of or a combination with OR of any of IEC_DATA, IEC_CLOCK,
IEC_ATN.

<tag/void cbm_iec_release(CBM_FILE f, int line);/
Release lines <it/line/ (set to 5V).
<it/line/ can be one of or a combination with OR of any of IEC_DATA, IEC_CLOCK,
IEC_ATN.


<tag/void cbm_iec_setrelease(CBM_FILE f, int setline, int resetline);/
Set lines <it/setline/ (set to 0V) and release line <it/releaseline/ (set to
5V)
<it/setline/ and <it/resetline/ can each be one of or a combination with OR of
any of IEC_DATA, IEC_CLOCK, IEC_ATN. If a line is part of both <it/setline/ and
<it/resetline/, the outcome is undefined.


<tag/int cbm_iec_wait(CBM_FILE f, int line, int state);/
Experimental, do not use.
</descrip>

<sect2>Helper functions<label id="opencbm-helper-functions">

<p><descrip>
<tag/int cbm_upload(CBM_FILE f, unsigned char dev, int adr, void *prog, int size);/
Write <it/prog/ into device <it/dev/'s memory space via a series of <tt/"M-W"/
commands.

<tag/int cbm_device_status(CBM_FILE f, unsigned char drv, void *buf, int bufsize);/
Read device status info <it/buf/, at most <it/bufsize/ bytes are read.
Returns <it/atoi(buf)/.

<tag/int cbm_exec_command(CBM_FILE f, unsigned char drv, void *cmd, int len);/
Execute command <it/cmd/. Returns number of bytes actually written.
if <it/len/ is 0, <it/cmd/ is considered a 0-terminated string.

<tag/int cbm_identify(CBM_FILE f, unsigned char drv, enum cbm_device_type_e *t, const char **type_str);/
Tries to identify the device <it/drv/. The hardware type is returned in <it/t/,
<it/type_str/ contains a descriptive string which also includes the drives'
operating system. Both <it/t/ and <it/type_str/ may be <tt/NULL/ in case the
caller is not interrested in any of both values.<p>
The return value is <tt/0/ if the device responded to the <tt/"M-R"/ command,
even if it could not be identified, &lt; 0 indicates error.

<tag/int cbm_identify_xp1541(CBM_FILE f, unsigned char drv, enum cbm_device_type_e *t1, enum cbm_cable_type_e *t2);/
Tries to identify the device <it/drv/. The hardware type is returned in <it/t1/,
<it/t2/ contains whether the drive has an parallel (XP1541) cable attached.
Both <it/t1/ and <it/t2/ may be <tt/NULL/ in case the caller is not interrested
in any of both values.<p>
The return value is <tt/0/ if the device responded to the <tt/"M-R"/ command,
even if it could not be identified, &lt; 0 indicates error.

</descrip>

<sect2>PetSCII functions<label id="opencbm-petscii-functions">

<p><descrip>
<tag/char cbm_petscii2ascii_c(char character);/
Converts one character <it/character/ from PetSCII to ASCII.

<tag/char cbm_ascii2petscii_c(char character);/
Converts one character <it/character/ from ASCII to PetSCII.

<tag/char * cbm_petscii2ascii(char *str);/
Convert a null-terminated string <it/str/ from PetSCII to ASCII.

<tag/char * cbm_ascii2petscii(char *str);/
Convert a null-terminated string <it/str/ from ASCII to PetSCII.

</descrip>

<sect2>Parallel Burst functions<label id="opencbm-parburst-functions">

<p><descrip>
<tag/unsigned char cbm_parallel_burst_read(CBM_FILE f);/
Support function for mnib. Do not use.

<tag/void cbm_parallel_burst_write(CBM_FILE f, unsigned char c);/
Support function for mnib. Do not use.

<tag/int cbm_parallel_burst_read_track(CBM_FILE f, unsigned char *buffer, unsigned int length);/
Support function for mnib. Do not use.

<tag/int cbm_parallel_burst_read_track_var(CBM_FILE f, unsigned char *buffer, unsigned int length);/
Support function for mnib. Do not use.

<tag/int cbm_parallel_burst_write_track(CBM_FILE f, unsigned char *buffer, unsigned int length);/
Support function for mnib. Do not use.

</descrip>

<sect2>libd64copy <it/TODO/<label id="opencbm-libd64copy-functions">
<p>
Not documented yet. See <it/libd64copy/ and <it/d64copy/ source.<p>
Types and prototypes are defined in <tt/d64copy.h/.

<sect2>libcbmcopy <it/TODO/<label id="opencbm-libcbmcopy-functions">
<p>
Not documented yet. See <it/libcbmcopy/ and <it/cbmcopy/ source.<p>
Types and prototypes are defined in <tt/cbmcopy.h/.
-->


<sect>Known bugs and problems<label id="knownbugs">
<p>
There are some known bugs in opencbm:

<itemize>
<item><it/cbmcopy/ is still known to have some protocol races, especially with
 1581 drives; thus, it does not always work reliably.
<item><it/cbmctrl detect/ as well as <it/cbmcopy/ and <it/d64copy/ do not
 recognize the drive type if some custom ROM is used.
 Whenever this happens, use <it/--drive-type/ for <it/cbmcopy/ and <it/d64copy/.
 Furthermore, I would be happy if you could send me a ROM dump of the floppy ROM
 so I can update the drive type recognition for some future version of OpenCBM.
<item>Windows: If you have any other devices connected to your parallel port,
 you cannot use them as long as OpenCBM is installed. In this case, either
 remove opencbm whenever you want to access that other device, or install
 opencbm with <it/instcbm --lock=no/ and make sure to issue <it/cbmctrl lock/
 before accessing the drive, and <it/cbmctrl unlock/ afterwards.
<item>Windows: No third party PCI or PCIe parallel port card does work with
  opencbm on Windows currently; to say it with other words: there
  is no proof or positive report that any third party PCI or PCIe
  parallel port card does or did work with opencbm on Windows. The exact
  failure reason is not known to date, but we are investigating
  further since that feature is a must, when integrated parallel
  ports were removed from mainstream mainboards in the future.
  Thus, it would be best if you use XU1541 or XUM1541 adapters instead
  of XA1541 and XM1541!
<item>Linux: PCI or PCIe based parallel port cards might work, but there
  is no guarantee for this.
  Thus, it would be best if you use XU1541 or XUM1541 adapters instead
  of XA1541 and XM1541!
<item>All: An XA1541 or XM1541 cable will definitely <em/not/ work with a
  USB-to-parallel-port adapter. These are commonly used to connect parallel port
  printers to modern PCs. However, neither do they offer full access to all
  parallel port lines, as it is needed for the XA1541/XM1541 cables, nor do they
  allow for the tight timing needed for XA1541/XM1541 cables.
<item>Windows: The <htmlurl url="http://sta.c64.org/sc.html" name="Star Commander">
  is supported on 32 bit versions of Windows.  For this, a special VXD driver
  is installed. The Star Commander then uses the VXD to communicate with the
  drive.
  This does not work for 64 bit Windows variants, though.
</itemize>

<sect>WARNINGS<label id="WARNINGS">

<p>
You should be careful when operating the adapters, in order to prevent any
damage to your drive or your adapter. The following general rules apply to all
of the XA1541, the XM1541, the XU1541 and the XUM1541 (ZoomFloppy) devices,
unless specified otherwise.

<itemize>
<item>
Do not plug or unplug any cables to the floppy drive when the drive is powered
on or the XU1541, XUM1541, or ZoomFloppy is connected to a PC via USB, or the
XA1541 is connected to the PC via the parallel port. When the USB based adapters
are plugged into USB, they are powered on and could zap your drive if you
connect or remove a floppy drive. This is also the same way you should treat
floppy drives attached to your Commodore computers.

<item>
Do not attach more than 4 floppy drives to a single ZoomFloppy. For the other
adapters (XU1541, general XUM1541, XA1541 or XM1541), other limits may be valid.
If you need more drives, get another ZoomFloppy or other adapter. The OpenCBM
softare allows you to use more than one adapter at the same time (subject to
PC performance limitations). These can be multiple adapters of the same type, or
of different ones.

<item>
Do not connect more than one drive to the XU1541, XUM1541, ZoomFloppy, or
XAP1541/XMP1541 parallel ports. While there are multiple connectors, only one
should be used at a time. Otherwise, chances are you will damage your floppy
drive!

<item>
When accessing floppy drives, all devices connected to the same IEC bus must be
turned on. Even if you are only going to use one drive, for example, all other
connected drives must also be turned on. Unpowered IEC devices may interfere
with proper operation of other drives.

<item>
Be careful of static electricity discharge when plugging/unplugging any
electronic components. Consider getting a case for your XU1541, XUM1541 or
ZoomFloppy board if you are concerned about the environment you will be using it
on.
</itemize>

<sect1>Proper power-on sequence

<p>
We have tested leaving the XU1541, XUM1541, ZoomFloppy, XA1541 or XM1541
adapters connected to powered-on drives for days with no problems, even though
they were not connected via USB or via the PC's parallel port. You can also
leave the adapters plugged into USB with the drive(s) off with no problems. But
while the ZoomFloppy is designed to be robust, you can avoid unnecessary wear by
following these instructions for starting up and shutting it down.  Other
adapters (XU1541, other XUM1541 variants, XA1541 or XM1541) may be even more
picky than the ZoomFloppy.

<sect2>Power-on sequence for USB based adapters

<p>
For USB based adapters (XU1541, XUM1541, ZoomFloppy), the following procedure
is recommended:

<enum>
<item>Start with drive off and XU1541, XUM1541, ZoomFloppy unplugged from the PC's USB;
<item>Plug in all cable(s) between XU1541, XUM1541, ZoomFloppy and drive(s);
<item>Plug in XU1541, XUM1541 or ZoomFloppy via USB;
<item>Turn on drive power switch(es).
</enum>

<p>
Turn off the equipment via the same sequence in reverse, at least doing steps 4
and 3. You don't need to unplug the floppy drive from XU1541, XUM1541 or
ZoomFloppy while not in use.

The 15x1 drives with an internal power supply tend to get hot if left on for a
long time, so you may want to power them off when not in use.

<sect2>Power-on sequence for PC parallel port based adapters

<p>For the parallel port based adapters (XA1541, XM1541, XAP1541, XMP1541), the following procedure
is recommended:

<enum>
<item>Start with drive off and XA1541, XM1541, XAP1541 or XMP1541 unplugged from
the PC's parallel port. Furthermore, leave the PC switched off;
<item>Plug in all cable(s) between XA1541, XM1541, XAP1541 or XMP1541 and drive(s);
<item>Plug in XA1541, XM1541, XAP1541 or XMP154 to the PC's parallel port;
<item>Turn on the PC
<item>Turn on drive power switch(es).
</enum>

<p>
Turn off the equipment via the same sequence in reverse, at least doing steps 5,
4 and 3. It is highly suggested to unplug the floppy drive(s) from the parallel
port while not in use, by removing the XA1541, XM1541, XAP1541 or XMP1541
adapter from the PC, at least.

The 15x1 drives with an internal power supply tend to get hot if left on for a
long time, so you may want to power them off when not in use.

<sect>Misc

<sect1>Credits

<p>
The fast format drive routine used by the original `cbmformat' and the turbo and
warp drive routines used in `libd64copy' and `libcbmcopy' are heavily based on
Joe Forster/STAs Star Commander routines.
The `cbmformat' routines were highly modified afterwards. The `cbmforng' drive
routine is derived from this, but was a massive rewrite by Wolfgang Moser.

The XP1541 and XP1571 cables (C) by Joe Forster/STA.
The original XE1541 cable (C) by Nicolas Welte and Wolfgang Moser
The XA1541 cable (C) by Michael Klein and Nicolas Welte
The XU1541 cable is copyright by a person who does not want to be mentioned
anymore.
The XUM1541 / ZoomFloppy cable is (C) Jim Brain and Nate Lawson.

<sect1>Contributions

<p>
People who directly or indirectly contributed to opencbm (in no particular
order):

<itemize>
<item>
<it/Michael Klein/ started the original cbm4linux work (which was a very big
part)
<item>
<it>Joe Forster/STA</it> made the Star Commander and supplied the source and
info about the X?1541 interfaces; who knows, without this work, opencbm might never
have appeared at all.
<item>
<it/Nicolas Welte/ helped with the XA1541 and XM1541 interfaces and supplied a
free factory-new 1571 mechanic for Michael
<item>
<it/Andreas Boose & the VICE team/ made VICE
<item>
<it/Andr Fachat/ made the xa 6502 crossassembler
<item>
<it/Ullrich von Bassewitz/ made the ca65 crossassembler as part of the cc65 package
<item>
<it/Oliver Schmidt/ took over the cc65 package (and, thus, the ca65
crossassembler) after Ullrich von Bassewitz retired from supporting it.
<item>
<it/Wolfgang Moser/ contributed <it/many/ discussions, patches, and hardware
whenever it was needed.
<item>
<it/Spiro Trikaliotis/ with discussions, lots of fixes and doing an overall
great review while porting the driver to "other" operating systems ;-)
<item>
<it/Christian Vogelgsang/ made the MacOS port and documented it.
<item>
<it/A person who does not want to be mentioned anymore/ for building the XU1541
device as low-cost variant and proof-of-concept that such a communication tool
can be built as USB device.
<item>
<it/Nate Lawson/ for building the XUM1541 firmware, especially for the
ZoomFloppy, in a collaborative effort with
<it/Jim Brain/ who built the ZoomFloppy hardware, which is the standard and best
tested implementation of the XUM1541 device.
<it/Uffe Jakobsen/ worked on FreeBSD ports and MacOS variants, and fixed many
other things especially for Linux.
<item>
<it/Frdric Brire/ made some enhancements especially for the Linux kernel
module for the XA1541/XM1541 devices.
<item>
<it/Markus Brenner/ wrote mnib, a parallel nibbler for DOS, that was later ported
by <it/Arnd Menge/ to also work with OpenCBM on Windows and Linux.
<item>
<it/Peter 'Pete' Rittwage/ took over mnib, renamed it to nibtools, and still
supports it.
<item>
<it/Arnd Menge/ not only ported mnib to the OpenCBM environment, he also made
many changes in many aspects, especially for the Windows version, for the
support of tape drives, and many other small and big things. He also added the
SRQ nibbling support which allows to use the nibtools without a parallel
connection for some drives.
<item>
<it/Thomas `Tommy' Winkler/ wrote <it/d82copy/ and <it/imgcopy/ and implemented
IEEE-488 support for the XUM1541.
<item>
<it/Jochen Adler/ for the IEC2IEEE device <htmlurl url="http://www.nlq.de/"
name="http://www.nlq.de/"> and for sending me free
hardware in order to test it with my SFD1001 and VIC 8250LP.
<item>
and anyone else who sent patches, suggestions, praises & flames!
</itemize>


<sect1>Feedback

<p>
Feel free to drop a note if you have ideas, patches etc. or if you just want to
tell how happy you are with this program ;-)


Have fun,

The opencbm team.

</article>
